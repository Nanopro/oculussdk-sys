#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused)]

/* automatically generated by rust-bindgen */
pub const OVR_PRODUCT_VERSION: u32 = 1;
pub const OVR_MAJOR_VERSION: u32 = 1;
pub const OVR_MINOR_VERSION: u32 = 43;
pub const OVR_PATCH_VERSION: u32 = 0;
pub const OVR_BUILD_NUMBER: u32 = 0;
pub const OVR_DLL_COMPATIBLE_VERSION: u32 = 101;
pub const OVR_MIN_REQUESTABLE_MINOR_VERSION: u32 = 17;
pub const OVR_FEATURE_VERSION: u32 = 0;
pub const OVR_FILE_DESCRIPTION_STRING: &'static [u8; 10usize] = b"dev build\0";
pub const OVR_KEY_USER: &'static [u8; 5usize] = b"User\0";
pub const OVR_KEY_NAME: &'static [u8; 5usize] = b"Name\0";
pub const OVR_KEY_GENDER: &'static [u8; 7usize] = b"Gender\0";
pub const OVR_DEFAULT_GENDER: &'static [u8; 8usize] = b"Unknown\0";
pub const OVR_KEY_PLAYER_HEIGHT: &'static [u8; 13usize] = b"PlayerHeight\0";
pub const OVR_DEFAULT_PLAYER_HEIGHT: f64 = 1.778;
pub const OVR_KEY_EYE_HEIGHT: &'static [u8; 10usize] = b"EyeHeight\0";
pub const OVR_DEFAULT_EYE_HEIGHT: f64 = 1.675;
pub const OVR_KEY_NECK_TO_EYE_DISTANCE: &'static [u8; 16usize] = b"NeckEyeDistance\0";
pub const OVR_DEFAULT_NECK_TO_EYE_HORIZONTAL: f64 = 0.0805;
pub const OVR_DEFAULT_NECK_TO_EYE_VERTICAL: f64 = 0.075;
pub const OVR_KEY_EYE_TO_NOSE_DISTANCE: &'static [u8; 14usize] = b"EyeToNoseDist\0";
pub const OVR_PERF_HUD_MODE: &'static [u8; 12usize] = b"PerfHudMode\0";
pub const OVR_LAYER_HUD_MODE: &'static [u8; 13usize] = b"LayerHudMode\0";
pub const OVR_LAYER_HUD_CURRENT_LAYER: &'static [u8; 21usize] = b"LayerHudCurrentLayer\0";
pub const OVR_LAYER_HUD_SHOW_ALL_LAYERS: &'static [u8; 16usize] = b"LayerHudShowAll\0";
pub const OVR_DEBUG_HUD_STEREO_MODE: &'static [u8; 19usize] = b"DebugHudStereoMode\0";
pub const OVR_DEBUG_HUD_STEREO_GUIDE_INFO_ENABLE: &'static [u8; 30usize] =
    b"DebugHudStereoGuideInfoEnable\0";
pub const OVR_DEBUG_HUD_STEREO_GUIDE_SIZE: &'static [u8; 26usize] = b"DebugHudStereoGuideSize2f\0";
pub const OVR_DEBUG_HUD_STEREO_GUIDE_POSITION: &'static [u8; 30usize] =
    b"DebugHudStereoGuidePosition3f\0";
pub const OVR_DEBUG_HUD_STEREO_GUIDE_YAWPITCHROLL: &'static [u8; 34usize] =
    b"DebugHudStereoGuideYawPitchRoll3f\0";
pub const OVR_DEBUG_HUD_STEREO_GUIDE_COLOR: &'static [u8; 27usize] =
    b"DebugHudStereoGuideColor4f\0";
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const OVR_PTR_SIZE: u32 = 8;
pub const ovrFalse: u32 = 0;
pub const ovrTrue: u32 = 1;
pub const OVR_MAX_EXTENSION_NAME_SIZE: u32 = 128;
pub const OVR_HAPTICS_BUFFER_SAMPLES_MAX: u32 = 256;
pub const OVR_MAX_EXTERNAL_CAMERA_COUNT: u32 = 16;
pub const OVR_EXTERNAL_CAMERA_NAME_SIZE: u32 = 32;
pub const OVR_HMD_CONNECTED_EVENT_NAME: &'static [u8; 19usize] = b"OculusHMDConnected\0";
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type size_t = ::std::os::raw::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[doc = " API call results are represented at the highest level by a single ovrResult."]
pub type ovrResult = i32;
#[doc = " This is a general success result. Use OVR_SUCCESS to test for success."]
pub const ovrSuccessType__ovrSuccess: ovrSuccessType_ = 0;
pub type ovrSuccessType_ = i32;
pub use self::ovrSuccessType_ as ovrSuccessType;
#[doc = " Returned from a call to SubmitFrame. The call succeeded, but what the app"]
#[doc = " rendered will not be visible on the HMD. Ideally the app should continue"]
#[doc = " calling SubmitFrame, but not do any rendering. When the result becomes"]
#[doc = " ovrSuccess, rendering should continue as usual."]
pub const ovrSuccessTypes__ovrSuccess_NotVisible: ovrSuccessTypes_ = 1000;
#[doc = " Boundary is invalid due to sensor change or was not setup."]
pub const ovrSuccessTypes__ovrSuccess_BoundaryInvalid: ovrSuccessTypes_ = 1001;
#[doc = " Device is not available for the requested operation."]
pub const ovrSuccessTypes__ovrSuccess_DeviceUnavailable: ovrSuccessTypes_ = 1002;
pub type ovrSuccessTypes_ = i32;
pub use self::ovrSuccessTypes_ as ovrSuccessTypes;
#[doc = " Failure to allocate memory."]
pub const ovrErrorType__ovrError_MemoryAllocationFailure: ovrErrorType_ = -1000;
#[doc = " Invalid ovrSession parameter provided."]
pub const ovrErrorType__ovrError_InvalidSession: ovrErrorType_ = -1002;
#[doc = " The operation timed out."]
pub const ovrErrorType__ovrError_Timeout: ovrErrorType_ = -1003;
#[doc = " The system or component has not been initialized."]
pub const ovrErrorType__ovrError_NotInitialized: ovrErrorType_ = -1004;
#[doc = " Invalid parameter provided. See error info or log for details."]
pub const ovrErrorType__ovrError_InvalidParameter: ovrErrorType_ = -1005;
#[doc = " Generic service error. See error info or log for details."]
pub const ovrErrorType__ovrError_ServiceError: ovrErrorType_ = -1006;
#[doc = " The given HMD doesn't exist."]
pub const ovrErrorType__ovrError_NoHmd: ovrErrorType_ = -1007;
#[doc = " Function call is not supported on this hardware/software"]
pub const ovrErrorType__ovrError_Unsupported: ovrErrorType_ = -1009;
#[doc = " Specified device type isn't available."]
pub const ovrErrorType__ovrError_DeviceUnavailable: ovrErrorType_ = -1010;
#[doc = " The headset was in an invalid orientation for the requested"]
#[doc = " operation (e.g. vertically oriented during ovr_RecenterPose)."]
pub const ovrErrorType__ovrError_InvalidHeadsetOrientation: ovrErrorType_ = -1011;
#[doc = " The client failed to call ovr_Destroy on an active session before calling ovr_Shutdown."]
#[doc = " Or the client crashed."]
pub const ovrErrorType__ovrError_ClientSkippedDestroy: ovrErrorType_ = -1012;
#[doc = " The client failed to call ovr_Shutdown or the client crashed."]
pub const ovrErrorType__ovrError_ClientSkippedShutdown: ovrErrorType_ = -1013;
pub const ovrErrorType__ovrError_ServiceDeadlockDetected: ovrErrorType_ = -1014;
pub const ovrErrorType__ovrError_InvalidOperation: ovrErrorType_ = -1015;
pub const ovrErrorType__ovrError_InsufficientArraySize: ovrErrorType_ = -1016;
#[doc = " There is not any external camera information stored by ovrServer."]
pub const ovrErrorType__ovrError_NoExternalCameraInfo: ovrErrorType_ = -1017;
#[doc = " Tracking is lost when ovr_GetDevicePoses() is called."]
pub const ovrErrorType__ovrError_LostTracking: ovrErrorType_ = -1018;
#[doc = " There was a problem initializing the external camera for capture"]
pub const ovrErrorType__ovrError_ExternalCameraInitializedFailed: ovrErrorType_ = -1019;
#[doc = " There was a problem capturing external camera frames"]
pub const ovrErrorType__ovrError_ExternalCameraCaptureFailed: ovrErrorType_ = -1020;
#[doc = " The external camera friendly name list and the external camera name list"]
#[doc = " are not the fixed size(OVR_MAX_EXTERNAL_CAMERA_NAME_BUFFER_SIZE)."]
pub const ovrErrorType__ovrError_ExternalCameraNameListsBufferSize: ovrErrorType_ = -1021;
#[doc = " The external camera friendly name list is not the same size as"]
#[doc = " the external camera name list."]
pub const ovrErrorType__ovrError_ExternalCameraNameListsMistmatch: ovrErrorType_ = -1022;
#[doc = " The external camera property has not been sent to OVRServer"]
#[doc = " when the user tries to open the camera."]
pub const ovrErrorType__ovrError_ExternalCameraNotCalibrated: ovrErrorType_ = -1023;
#[doc = " The external camera name is larger than OVR_EXTERNAL_CAMERA_NAME_SIZE-1"]
pub const ovrErrorType__ovrError_ExternalCameraNameWrongSize: ovrErrorType_ = -1024;
#[doc = " The caller doesn't have permissions for the requested action."]
pub const ovrErrorType__ovrError_AccessDenied: ovrErrorType_ = -1025;
#[doc = " Failure to find the specified audio device."]
pub const ovrErrorType__ovrError_AudioDeviceNotFound: ovrErrorType_ = -2001;
#[doc = " Generic COM error."]
pub const ovrErrorType__ovrError_AudioComError: ovrErrorType_ = -2002;
#[doc = " Generic initialization error."]
pub const ovrErrorType__ovrError_Initialize: ovrErrorType_ = -3000;
#[doc = " Couldn't load LibOVRRT."]
pub const ovrErrorType__ovrError_LibLoad: ovrErrorType_ = -3001;
#[doc = " LibOVRRT version incompatibility."]
pub const ovrErrorType__ovrError_LibVersion: ovrErrorType_ = -3002;
#[doc = " Couldn't connect to the OVR Service."]
pub const ovrErrorType__ovrError_ServiceConnection: ovrErrorType_ = -3003;
#[doc = " OVR Service version incompatibility."]
pub const ovrErrorType__ovrError_ServiceVersion: ovrErrorType_ = -3004;
#[doc = " The operating system version is incompatible."]
pub const ovrErrorType__ovrError_IncompatibleOS: ovrErrorType_ = -3005;
#[doc = " Unable to initialize the HMD display."]
pub const ovrErrorType__ovrError_DisplayInit: ovrErrorType_ = -3006;
#[doc = " Unable to start the server. Is it already running?"]
pub const ovrErrorType__ovrError_ServerStart: ovrErrorType_ = -3007;
#[doc = " Attempting to re-initialize with a different version."]
pub const ovrErrorType__ovrError_Reinitialization: ovrErrorType_ = -3008;
#[doc = " Chosen rendering adapters between client and service do not match"]
pub const ovrErrorType__ovrError_MismatchedAdapters: ovrErrorType_ = -3009;
#[doc = " Calling application has leaked resources"]
pub const ovrErrorType__ovrError_LeakingResources: ovrErrorType_ = -3010;
#[doc = " Client version too old to connect to service"]
pub const ovrErrorType__ovrError_ClientVersion: ovrErrorType_ = -3011;
#[doc = " The operating system is out of date."]
pub const ovrErrorType__ovrError_OutOfDateOS: ovrErrorType_ = -3012;
#[doc = " The graphics driver is out of date."]
pub const ovrErrorType__ovrError_OutOfDateGfxDriver: ovrErrorType_ = -3013;
#[doc = " The graphics hardware is not supported"]
pub const ovrErrorType__ovrError_IncompatibleGPU: ovrErrorType_ = -3014;
#[doc = " No valid VR display system found."]
pub const ovrErrorType__ovrError_NoValidVRDisplaySystem: ovrErrorType_ = -3015;
#[doc = " Feature or API is obsolete and no longer supported."]
pub const ovrErrorType__ovrError_Obsolete: ovrErrorType_ = -3016;
#[doc = " No supported VR display system found, but disabled or driverless adapter found."]
pub const ovrErrorType__ovrError_DisabledOrDefaultAdapter: ovrErrorType_ = -3017;
#[doc = " The system is using hybrid graphics (Optimus, etc...), which is not support."]
pub const ovrErrorType__ovrError_HybridGraphicsNotSupported: ovrErrorType_ = -3018;
#[doc = " Initialization of the DisplayManager failed."]
pub const ovrErrorType__ovrError_DisplayManagerInit: ovrErrorType_ = -3019;
#[doc = " Failed to get the interface for an attached tracker"]
pub const ovrErrorType__ovrError_TrackerDriverInit: ovrErrorType_ = -3020;
#[doc = " LibOVRRT signature check failure."]
pub const ovrErrorType__ovrError_LibSignCheck: ovrErrorType_ = -3021;
#[doc = " LibOVRRT path failure."]
pub const ovrErrorType__ovrError_LibPath: ovrErrorType_ = -3022;
#[doc = " LibOVRRT symbol resolution failure."]
pub const ovrErrorType__ovrError_LibSymbols: ovrErrorType_ = -3023;
#[doc = " Failed to connect to the service because remote connections to the service are not allowed."]
pub const ovrErrorType__ovrError_RemoteSession: ovrErrorType_ = -3024;
#[doc = " Vulkan initialization error."]
pub const ovrErrorType__ovrError_InitializeVulkan: ovrErrorType_ = -3025;
#[doc = " The graphics driver is black-listed."]
pub const ovrErrorType__ovrError_BlacklistedGfxDriver: ovrErrorType_ = -3026;
#[doc = " In the event of a system-wide graphics reset or cable unplug this is returned to the app."]
pub const ovrErrorType__ovrError_DisplayLost: ovrErrorType_ = -6000;
#[doc = " ovr_CommitTextureSwapChain was called too many times on a texture swapchain without"]
#[doc = " calling submit to use the chain."]
pub const ovrErrorType__ovrError_TextureSwapChainFull: ovrErrorType_ = -6001;
#[doc = " The ovrTextureSwapChain is in an incomplete or inconsistent state."]
#[doc = " Ensure ovr_CommitTextureSwapChain was called at least once first."]
pub const ovrErrorType__ovrError_TextureSwapChainInvalid: ovrErrorType_ = -6002;
#[doc = " Graphics device has been reset (TDR, etc...)"]
pub const ovrErrorType__ovrError_GraphicsDeviceReset: ovrErrorType_ = -6003;
#[doc = " HMD removed from the display adapter"]
pub const ovrErrorType__ovrError_DisplayRemoved: ovrErrorType_ = -6004;
#[doc = " Content protection is not available for the display."]
pub const ovrErrorType__ovrError_ContentProtectionNotAvailable: ovrErrorType_ = -6005;
#[doc = " Application declared itself as an invisible type and is not allowed to submit frames."]
pub const ovrErrorType__ovrError_ApplicationInvisible: ovrErrorType_ = -6006;
#[doc = " The given request is disallowed under the current conditions."]
pub const ovrErrorType__ovrError_Disallowed: ovrErrorType_ = -6007;
#[doc = " Display portion of HMD is plugged into an incompatible port (ex: IGP)"]
pub const ovrErrorType__ovrError_DisplayPluggedIncorrectly: ovrErrorType_ = -6008;
#[doc = " Returned in the event a virtual display system reaches a display limit"]
pub const ovrErrorType__ovrError_DisplayLimitReached: ovrErrorType_ = -6009;
#[doc = " re-initialize it before this error state will be cleared."]
pub const ovrErrorType__ovrError_RuntimeException: ovrErrorType_ = -7000;
#[doc = " Result of a missing calibration block"]
pub const ovrErrorType__ovrError_NoCalibration: ovrErrorType_ = -9000;
#[doc = " Result of an old calibration block"]
pub const ovrErrorType__ovrError_OldVersion: ovrErrorType_ = -9001;
#[doc = " Result of a bad calibration block due to lengths"]
pub const ovrErrorType__ovrError_MisformattedBlock: ovrErrorType_ = -9002;
pub type ovrErrorType_ = i32;
pub use self::ovrErrorType_ as ovrErrorType;
#[doc = " Provides information about the last error."]
#[doc = " \\see ovr_GetLastErrorInfo"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrErrorInfo_ {
    #[doc = " The result from the last API call that generated an error ovrResult."]
    pub Result: ovrResult,
    #[doc = " A UTF8-encoded null-terminated English string describing the problem."]
    #[doc = " The format of this string is subject to change in future versions."]
    pub ErrorString: [::std::os::raw::c_char; 512usize],
}
#[test]
fn bindgen_test_layout_ovrErrorInfo_() {
    assert_eq!(
        ::std::mem::size_of::<ovrErrorInfo_>(),
        516usize,
        concat!("Size of: ", stringify!(ovrErrorInfo_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrErrorInfo_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrErrorInfo_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrErrorInfo_>())).Result as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrErrorInfo_),
            "::",
            stringify!(Result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrErrorInfo_>())).ErrorString as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrErrorInfo_),
            "::",
            stringify!(ErrorString)
        )
    );
}
pub type ovrErrorInfo = ovrErrorInfo_;
pub type ovrBool = ::std::os::raw::c_char;
#[doc = " Defines a generic function pointer."]
#[doc = ""]
#[doc = " \\see ovr_GetInstanceProcAddr"]
#[doc = ""]
pub type PFN_ovrVoidFunction = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " A RGBA color with normalized float components."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrColorf_ {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
#[test]
fn bindgen_test_layout_ovrColorf_() {
    assert_eq!(
        ::std::mem::size_of::<ovrColorf_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrColorf_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrColorf_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrColorf_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrColorf_>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrColorf_),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrColorf_>())).g as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrColorf_),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrColorf_>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrColorf_),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrColorf_>())).a as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrColorf_),
            "::",
            stringify!(a)
        )
    );
}
pub type ovrColorf = ovrColorf_;
#[doc = " A 2D vector with integer components."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector2i_ {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrVector2i_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector2i_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrVector2i_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector2i_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrVector2i_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector2i_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector2i_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector2i_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector2i_),
            "::",
            stringify!(y)
        )
    );
}
pub type ovrVector2i = ovrVector2i_;
#[doc = " A 2D size with integer components."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrSizei_ {
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrSizei_() {
    assert_eq!(
        ::std::mem::size_of::<ovrSizei_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrSizei_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrSizei_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrSizei_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSizei_>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSizei_),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSizei_>())).h as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSizei_),
            "::",
            stringify!(h)
        )
    );
}
pub type ovrSizei = ovrSizei_;
#[doc = " A 2D rectangle with a position and size."]
#[doc = " All components are integers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrRecti_ {
    pub Pos: ovrVector2i,
    pub Size: ovrSizei,
}
#[test]
fn bindgen_test_layout_ovrRecti_() {
    assert_eq!(
        ::std::mem::size_of::<ovrRecti_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrRecti_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrRecti_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrRecti_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRecti_>())).Pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRecti_),
            "::",
            stringify!(Pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRecti_>())).Size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRecti_),
            "::",
            stringify!(Size)
        )
    );
}
pub type ovrRecti = ovrRecti_;
#[doc = " A quaternion rotation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrQuatf_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_ovrQuatf_() {
    assert_eq!(
        ::std::mem::size_of::<ovrQuatf_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrQuatf_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrQuatf_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrQuatf_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(w)
        )
    );
}
pub type ovrQuatf = ovrQuatf_;
#[doc = " A 2D vector with float components."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector2f_ {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_ovrVector2f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector2f_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrVector2f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector2f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrVector2f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector2f_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector2f_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector2f_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector2f_),
            "::",
            stringify!(y)
        )
    );
}
pub type ovrVector2f = ovrVector2f_;
#[doc = " A 3D vector with float components."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector3f_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_ovrVector3f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector3f_>(),
        12usize,
        concat!("Size of: ", stringify!(ovrVector3f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector3f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrVector3f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector3f_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector3f_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector3f_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector3f_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector3f_>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector3f_),
            "::",
            stringify!(z)
        )
    );
}
pub type ovrVector3f = ovrVector3f_;
#[doc = " A 4D vector with float components."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector4f_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_ovrVector4f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector4f_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrVector4f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector4f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrVector4f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(w)
        )
    );
}
pub type ovrVector4f = ovrVector4f_;
#[doc = " A 4x4 matrix with float elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrMatrix4f_ {
    pub M: [[f32; 4usize]; 4usize],
}
#[test]
fn bindgen_test_layout_ovrMatrix4f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrMatrix4f_>(),
        64usize,
        concat!("Size of: ", stringify!(ovrMatrix4f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrMatrix4f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrMatrix4f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrMatrix4f_>())).M as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrMatrix4f_),
            "::",
            stringify!(M)
        )
    );
}
pub type ovrMatrix4f = ovrMatrix4f_;
#[doc = " Position and orientation together."]
#[doc = " The coordinate system used is right-handed Cartesian."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrPosef_ {
    pub Orientation: ovrQuatf,
    pub Position: ovrVector3f,
}
#[test]
fn bindgen_test_layout_ovrPosef_() {
    assert_eq!(
        ::std::mem::size_of::<ovrPosef_>(),
        28usize,
        concat!("Size of: ", stringify!(ovrPosef_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrPosef_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrPosef_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPosef_>())).Orientation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPosef_),
            "::",
            stringify!(Orientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPosef_>())).Position as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPosef_),
            "::",
            stringify!(Position)
        )
    );
}
pub type ovrPosef = ovrPosef_;
#[doc = " A full pose (rigid body) configuration with first and second derivatives."]
#[doc = ""]
#[doc = " Body refers to any object for which ovrPoseStatef is providing data."]
#[doc = " It can be the HMD, Touch controller, sensor or something else. The context"]
#[doc = " depends on the usage of the struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrPoseStatef_ {
    #[doc = "< Position and orientation."]
    pub ThePose: ovrPosef,
    #[doc = "< Angular velocity in radians per second."]
    pub AngularVelocity: ovrVector3f,
    #[doc = "< Velocity in meters per second."]
    pub LinearVelocity: ovrVector3f,
    #[doc = "< Angular acceleration in radians per second per second."]
    pub AngularAcceleration: ovrVector3f,
    #[doc = "< Acceleration in meters per second per second."]
    pub LinearAcceleration: ovrVector3f,
    pub pad0: [::std::os::raw::c_char; 4usize],
    #[doc = "< Absolute time that this pose refers to. \\see ovr_GetTimeInSeconds"]
    pub TimeInSeconds: f64,
}
#[test]
fn bindgen_test_layout_ovrPoseStatef_() {
    assert_eq!(
        ::std::mem::size_of::<ovrPoseStatef_>(),
        88usize,
        concat!("Size of: ", stringify!(ovrPoseStatef_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrPoseStatef_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrPoseStatef_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPoseStatef_>())).ThePose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPoseStatef_),
            "::",
            stringify!(ThePose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPoseStatef_>())).AngularVelocity as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPoseStatef_),
            "::",
            stringify!(AngularVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPoseStatef_>())).LinearVelocity as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPoseStatef_),
            "::",
            stringify!(LinearVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPoseStatef_>())).AngularAcceleration as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPoseStatef_),
            "::",
            stringify!(AngularAcceleration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPoseStatef_>())).LinearAcceleration as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPoseStatef_),
            "::",
            stringify!(LinearAcceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPoseStatef_>())).pad0 as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPoseStatef_),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPoseStatef_>())).TimeInSeconds as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPoseStatef_),
            "::",
            stringify!(TimeInSeconds)
        )
    );
}
pub type ovrPoseStatef = ovrPoseStatef_;
#[doc = " Describes the up, down, left, and right angles of the field of view."]
#[doc = ""]
#[doc = " Field Of View (FOV) tangent of the angle units."]
#[doc = " \\note For a standard 90 degree vertical FOV, we would"]
#[doc = " have: { UpTan = tan(90 degrees / 2), DownTan = tan(90 degrees / 2) }."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrFovPort_ {
    #[doc = "< Tangent of the angle between the viewing vector and top edge of the FOV."]
    pub UpTan: f32,
    #[doc = "< Tangent of the angle between the viewing vector and bottom edge of the FOV."]
    pub DownTan: f32,
    #[doc = "< Tangent of the angle between the viewing vector and left edge of the FOV."]
    pub LeftTan: f32,
    #[doc = "< Tangent of the angle between the viewing vector and right edge of the FOV."]
    pub RightTan: f32,
}
#[test]
fn bindgen_test_layout_ovrFovPort_() {
    assert_eq!(
        ::std::mem::size_of::<ovrFovPort_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrFovPort_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrFovPort_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrFovPort_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFovPort_>())).UpTan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovPort_),
            "::",
            stringify!(UpTan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFovPort_>())).DownTan as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovPort_),
            "::",
            stringify!(DownTan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFovPort_>())).LeftTan as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovPort_),
            "::",
            stringify!(LeftTan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFovPort_>())).RightTan as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovPort_),
            "::",
            stringify!(RightTan)
        )
    );
}
pub type ovrFovPort = ovrFovPort_;
pub const ovrHmdType__ovrHmd_None: ovrHmdType_ = 0;
pub const ovrHmdType__ovrHmd_DK1: ovrHmdType_ = 3;
pub const ovrHmdType__ovrHmd_DKHD: ovrHmdType_ = 4;
pub const ovrHmdType__ovrHmd_DK2: ovrHmdType_ = 6;
pub const ovrHmdType__ovrHmd_CB: ovrHmdType_ = 8;
pub const ovrHmdType__ovrHmd_Other: ovrHmdType_ = 9;
pub const ovrHmdType__ovrHmd_E3_2015: ovrHmdType_ = 10;
pub const ovrHmdType__ovrHmd_ES06: ovrHmdType_ = 11;
pub const ovrHmdType__ovrHmd_ES09: ovrHmdType_ = 12;
pub const ovrHmdType__ovrHmd_ES11: ovrHmdType_ = 13;
pub const ovrHmdType__ovrHmd_CV1: ovrHmdType_ = 14;
pub const ovrHmdType__ovrHmd_RiftS: ovrHmdType_ = 16;
#[doc = "< \\internal Force type int32_t."]
pub const ovrHmdType__ovrHmd_EnumSize: ovrHmdType_ = 2147483647;
#[doc = " Enumerates all HMD types that we support."]
#[doc = ""]
#[doc = " The currently released developer kits are ovrHmd_DK1 and ovrHmd_DK2."]
#[doc = " The other enumerations are for internal use only."]
pub type ovrHmdType_ = i32;
pub use self::ovrHmdType_ as ovrHmdType;
#[doc = " <B>(read only)</B> Specifies that the HMD is a virtual debug device."]
pub const ovrHmdCaps__ovrHmdCap_DebugDevice: ovrHmdCaps_ = 16;
#[doc = "< \\internal Force type int32_t."]
pub const ovrHmdCaps__ovrHmdCap_EnumSize: ovrHmdCaps_ = 2147483647;
#[doc = " HMD capability bits reported by device."]
#[doc = ""]
pub type ovrHmdCaps_ = i32;
pub use self::ovrHmdCaps_ as ovrHmdCaps;
#[doc = "< Supports orientation tracking (IMU)."]
pub const ovrTrackingCaps__ovrTrackingCap_Orientation: ovrTrackingCaps_ = 16;
#[doc = "< Supports yaw drift correction."]
pub const ovrTrackingCaps__ovrTrackingCap_MagYawCorrection: ovrTrackingCaps_ = 32;
#[doc = "< Supports positional tracking."]
pub const ovrTrackingCaps__ovrTrackingCap_Position: ovrTrackingCaps_ = 64;
#[doc = "< \\internal Force type int32_t."]
pub const ovrTrackingCaps__ovrTrackingCap_EnumSize: ovrTrackingCaps_ = 2147483647;
#[doc = " Tracking capability bits reported by the device."]
#[doc = " Used with ovr_GetTrackingCaps."]
pub type ovrTrackingCaps_ = i32;
pub use self::ovrTrackingCaps_ as ovrTrackingCaps;
#[doc = " Describes the properties of an API extension."]
#[doc = ""]
#[doc = " \\see ovr_EnumerateInstanceExtensionProperties"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrExtensionProperties_ {
    pub extensionId: ::std::os::raw::c_int,
    pub extensionName: [::std::os::raw::c_char; 128usize],
    pub extensionVersion: u32,
}
#[test]
fn bindgen_test_layout_ovrExtensionProperties_() {
    assert_eq!(
        ::std::mem::size_of::<ovrExtensionProperties_>(),
        136usize,
        concat!("Size of: ", stringify!(ovrExtensionProperties_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrExtensionProperties_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrExtensionProperties_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrExtensionProperties_>())).extensionId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrExtensionProperties_),
            "::",
            stringify!(extensionId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrExtensionProperties_>())).extensionName as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrExtensionProperties_),
            "::",
            stringify!(extensionName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrExtensionProperties_>())).extensionVersion as *const _
                as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrExtensionProperties_),
            "::",
            stringify!(extensionVersion)
        )
    );
}
pub type ovrExtensionProperties = ovrExtensionProperties_;
#[doc = "< Enable before first layer submission."]
pub const ovrExtensions__ovrExtension_TextureLayout_Octilinear: ovrExtensions_ = 0;
#[doc = "< \\internal Sanity checking"]
pub const ovrExtensions__ovrExtension_Count: ovrExtensions_ = 1;
#[doc = "< \\internal Force type int32_t."]
pub const ovrExtensions__ovrExtension_EnumSize: ovrExtensions_ = 2147483647;
#[doc = " Optional extensions"]
pub type ovrExtensions_ = i32;
pub use self::ovrExtensions_ as ovrExtensions;
#[doc = "< The left eye, from the viewer's perspective."]
pub const ovrEyeType__ovrEye_Left: ovrEyeType_ = 0;
#[doc = "< The right eye, from the viewer's perspective."]
pub const ovrEyeType__ovrEye_Right: ovrEyeType_ = 1;
#[doc = "< \\internal Count of enumerated elements."]
pub const ovrEyeType__ovrEye_Count: ovrEyeType_ = 2;
#[doc = "< \\internal Force type int32_t."]
pub const ovrEyeType__ovrEye_EnumSize: ovrEyeType_ = 2147483647;
#[doc = " Specifies which eye is being used for rendering."]
#[doc = " This type explicitly does not include a third \"NoStereo\" monoscopic option,"]
#[doc = " as such is not required for an HMD-centered API."]
pub type ovrEyeType_ = i32;
pub use self::ovrEyeType_ as ovrEyeType;
#[doc = " \\brief Tracking system origin reported at eye (HMD) height"]
#[doc = " \\details Prefer using this origin when your application requires"]
#[doc = " matching user's current physical head pose to a virtual head pose"]
#[doc = " without any regards to a the height of the floor. Cockpit-based,"]
#[doc = " or 3rd-person experiences are ideal candidates."]
#[doc = " When used, all poses in ovrTrackingState are reported as an offset"]
#[doc = " transform from the profile calibrated or recentered HMD pose."]
#[doc = " It is recommended that apps using this origin type call ovr_RecenterTrackingOrigin"]
#[doc = " prior to starting the VR experience, but notify the user before doing so"]
#[doc = " to make sure the user is in a comfortable pose, facing a comfortable"]
#[doc = " direction."]
pub const ovrTrackingOrigin__ovrTrackingOrigin_EyeLevel: ovrTrackingOrigin_ = 0;
#[doc = " \\brief Tracking system origin reported at floor height"]
#[doc = " \\details Prefer using this origin when your application requires the"]
#[doc = " physical floor height to match the virtual floor height, such as"]
#[doc = " standing experiences."]
#[doc = " When used, all poses in ovrTrackingState are reported as an offset"]
#[doc = " transform from the profile calibrated floor pose. Calling ovr_RecenterTrackingOrigin"]
#[doc = " will recenter the X & Z axes as well as yaw, but the Y-axis (i.e. height) will continue"]
#[doc = " to be reported using the floor height as the origin for all poses."]
pub const ovrTrackingOrigin__ovrTrackingOrigin_FloorLevel: ovrTrackingOrigin_ = 1;
#[doc = "< \\internal Count of enumerated elements."]
pub const ovrTrackingOrigin__ovrTrackingOrigin_Count: ovrTrackingOrigin_ = 2;
#[doc = "< \\internal Force type int32_t."]
pub const ovrTrackingOrigin__ovrTrackingOrigin_EnumSize: ovrTrackingOrigin_ = 2147483647;
#[doc = " Specifies the coordinate system ovrTrackingState returns tracking poses in."]
#[doc = " Used with ovr_SetTrackingOriginType()"]
pub type ovrTrackingOrigin_ = i32;
pub use self::ovrTrackingOrigin_ as ovrTrackingOrigin;
#[doc = " Identifies a graphics device in a platform-specific way."]
#[doc = " For Windows this is a LUID type."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ovrGraphicsLuid_ {
    pub Reserved: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_ovrGraphicsLuid_() {
    assert_eq!(
        ::std::mem::size_of::<ovrGraphicsLuid_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrGraphicsLuid_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrGraphicsLuid_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrGraphicsLuid_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrGraphicsLuid_>())).Reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrGraphicsLuid_),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type ovrGraphicsLuid = ovrGraphicsLuid_;
#[doc = " This is a complete descriptor of the HMD."]
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct ovrHmdDesc_ {
    #[doc = "< The type of HMD."]
    pub Type: ovrHmdType,
    pub pad0: [::std::os::raw::c_char; 4usize],
    #[doc = "< UTF8-encoded product identification string (e.g. \"Oculus Rift DK1\")."]
    pub ProductName: [::std::os::raw::c_char; 64usize],
    #[doc = "< UTF8-encoded HMD manufacturer identification string."]
    pub Manufacturer: [::std::os::raw::c_char; 64usize],
    #[doc = "< HID (USB) vendor identifier of the device."]
    pub VendorId: ::std::os::raw::c_short,
    #[doc = "< HID (USB) product identifier of the device."]
    pub ProductId: ::std::os::raw::c_short,
    #[doc = "< HMD serial number."]
    pub SerialNumber: [::std::os::raw::c_char; 24usize],
    #[doc = "< HMD firmware major version."]
    pub FirmwareMajor: ::std::os::raw::c_short,
    #[doc = "< HMD firmware minor version."]
    pub FirmwareMinor: ::std::os::raw::c_short,
    #[doc = "< Available ovrHmdCaps bits."]
    pub AvailableHmdCaps: ::std::os::raw::c_uint,
    #[doc = "< Default ovrHmdCaps bits."]
    pub DefaultHmdCaps: ::std::os::raw::c_uint,
    #[doc = "< Available ovrTrackingCaps bits."]
    pub AvailableTrackingCaps: ::std::os::raw::c_uint,
    #[doc = "< Default ovrTrackingCaps bits."]
    pub DefaultTrackingCaps: ::std::os::raw::c_uint,
    #[doc = "< Defines the recommended FOVs for the HMD."]
    pub DefaultEyeFov: [ovrFovPort; 2usize],
    #[doc = "< Defines the maximum FOVs for the HMD."]
    pub MaxEyeFov: [ovrFovPort; 2usize],
    #[doc = "< Resolution of the full HMD screen (both eyes) in pixels."]
    pub Resolution: ovrSizei,
    #[doc = "< Refresh rate of the display in cycles per second."]
    pub DisplayRefreshRate: f32,
    pub pad1: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_ovrHmdDesc_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHmdDesc_>(),
        264usize,
        concat!("Size of: ", stringify!(ovrHmdDesc_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHmdDesc_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrHmdDesc_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).pad0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).ProductName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(ProductName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).Manufacturer as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(Manufacturer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).VendorId as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(VendorId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).ProductId as *const _ as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(ProductId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).SerialNumber as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(SerialNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).FirmwareMajor as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(FirmwareMajor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).FirmwareMinor as *const _ as usize },
        166usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(FirmwareMinor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).AvailableHmdCaps as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(AvailableHmdCaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).DefaultHmdCaps as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(DefaultHmdCaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrHmdDesc_>())).AvailableTrackingCaps as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(AvailableTrackingCaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).DefaultTrackingCaps as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(DefaultTrackingCaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).DefaultEyeFov as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(DefaultEyeFov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).MaxEyeFov as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(MaxEyeFov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).Resolution as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(Resolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).DisplayRefreshRate as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(DisplayRefreshRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdDesc_>())).pad1 as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdDesc_),
            "::",
            stringify!(pad1)
        )
    );
}
pub type ovrHmdDesc = ovrHmdDesc_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrHmdStruct {
    _unused: [u8; 0],
}
#[doc = " Used as an opaque pointer to an OVR session."]
pub type ovrSession = *mut ovrHmdStruct;
pub type ovrProcessId = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInstance_T {
    _unused: [u8; 0],
}
pub type VkInstance = *mut VkInstance_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice_T {
    _unused: [u8; 0],
}
pub type VkPhysicalDevice = *mut VkPhysicalDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDevice_T {
    _unused: [u8; 0],
}
pub type VkDevice = *mut VkDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueue_T {
    _unused: [u8; 0],
}
pub type VkQueue = *mut VkQueue_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImage_T {
    _unused: [u8; 0],
}
pub type VkImage = *mut VkImage_T;
pub const ovrStatusBits__ovrStatus_OrientationTracked: ovrStatusBits_ = 1;
pub const ovrStatusBits__ovrStatus_PositionTracked: ovrStatusBits_ = 2;
pub const ovrStatusBits__ovrStatus_OrientationValid: ovrStatusBits_ = 4;
pub const ovrStatusBits__ovrStatus_PositionValid: ovrStatusBits_ = 8;
#[doc = " Bit flags describing the current status of sensor tracking."]
#[doc = "  The values must be the same as in enum StatusBits"]
#[doc = ""]
#[doc = " \\see ovrTrackingState"]
#[doc = ""]
pub type ovrStatusBits_ = i32;
pub use self::ovrStatusBits_ as ovrStatusBits;
#[doc = "  Specifies the description of a single sensor."]
#[doc = ""]
#[doc = " \\see ovr_GetTrackerDesc"]
#[doc = ""]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ovrTrackerDesc_ {
    #[doc = "< Sensor frustum horizontal field-of-view (if present)."]
    pub FrustumHFovInRadians: f32,
    #[doc = "< Sensor frustum vertical field-of-view (if present)."]
    pub FrustumVFovInRadians: f32,
    #[doc = "< Sensor frustum near Z (if present)."]
    pub FrustumNearZInMeters: f32,
    #[doc = "< Sensor frustum far Z (if present)."]
    pub FrustumFarZInMeters: f32,
}
#[test]
fn bindgen_test_layout_ovrTrackerDesc_() {
    assert_eq!(
        ::std::mem::size_of::<ovrTrackerDesc_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrTrackerDesc_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTrackerDesc_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrTrackerDesc_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTrackerDesc_>())).FrustumHFovInRadians as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTrackerDesc_),
            "::",
            stringify!(FrustumHFovInRadians)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTrackerDesc_>())).FrustumVFovInRadians as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTrackerDesc_),
            "::",
            stringify!(FrustumVFovInRadians)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTrackerDesc_>())).FrustumNearZInMeters as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTrackerDesc_),
            "::",
            stringify!(FrustumNearZInMeters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTrackerDesc_>())).FrustumFarZInMeters as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTrackerDesc_),
            "::",
            stringify!(FrustumFarZInMeters)
        )
    );
}
pub type ovrTrackerDesc = ovrTrackerDesc_;
#[doc = " The sensor is present, else the sensor is absent or offline."]
pub const ovrTrackerFlags__ovrTracker_Connected: ovrTrackerFlags_ = 32;
#[doc = " The sensor has a valid pose, else the pose is unavailable."]
#[doc = " This will only be set if ovrTracker_Connected is set."]
pub const ovrTrackerFlags__ovrTracker_PoseTracked: ovrTrackerFlags_ = 4;
#[doc = "  Specifies sensor flags."]
#[doc = ""]
#[doc = "  /see ovrTrackerPose"]
#[doc = ""]
pub type ovrTrackerFlags_ = i32;
pub use self::ovrTrackerFlags_ as ovrTrackerFlags;
#[doc = "  Specifies the pose for a single sensor."]
#[doc = ""]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _ovrTrackerPose {
    #[doc = " ovrTrackerFlags."]
    pub TrackerFlags: ::std::os::raw::c_uint,
    #[doc = " The sensor's pose. This pose includes sensor tilt (roll and pitch)."]
    #[doc = " For a leveled coordinate system use LeveledPose."]
    pub Pose: ovrPosef,
    #[doc = " The sensor's leveled pose, aligned with gravity. This value includes pos and yaw of the"]
    #[doc = " sensor, but not roll and pitch. It can be used as a reference point to render real-world"]
    #[doc = " objects in the correct location."]
    pub LeveledPose: ovrPosef,
    pub pad0: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout__ovrTrackerPose() {
    assert_eq!(
        ::std::mem::size_of::<_ovrTrackerPose>(),
        64usize,
        concat!("Size of: ", stringify!(_ovrTrackerPose))
    );
    assert_eq!(
        ::std::mem::align_of::<_ovrTrackerPose>(),
        8usize,
        concat!("Alignment of ", stringify!(_ovrTrackerPose))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ovrTrackerPose>())).TrackerFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ovrTrackerPose),
            "::",
            stringify!(TrackerFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ovrTrackerPose>())).Pose as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ovrTrackerPose),
            "::",
            stringify!(Pose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ovrTrackerPose>())).LeveledPose as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ovrTrackerPose),
            "::",
            stringify!(LeveledPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ovrTrackerPose>())).pad0 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_ovrTrackerPose),
            "::",
            stringify!(pad0)
        )
    );
}
pub type ovrTrackerPose = _ovrTrackerPose;
#[doc = " Tracking state at a given absolute time (describes predicted HMD pose, etc.)."]
#[doc = " Returned by ovr_GetTrackingState."]
#[doc = ""]
#[doc = " \\see ovr_GetTrackingState"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrTrackingState_ {
    #[doc = " Predicted head pose (and derivatives) at the requested absolute time."]
    pub HeadPose: ovrPoseStatef,
    #[doc = " HeadPose tracking status described by ovrStatusBits."]
    pub StatusFlags: ::std::os::raw::c_uint,
    #[doc = " The most recent calculated pose for each hand when hand controller tracking is present."]
    #[doc = " HandPoses[ovrHand_Left] refers to the left hand and HandPoses[ovrHand_Right] to the right."]
    #[doc = " These values can be combined with ovrInputState for complete hand controller information."]
    pub HandPoses: [ovrPoseStatef; 2usize],
    #[doc = " HandPoses status flags described by ovrStatusBits."]
    pub HandStatusFlags: [::std::os::raw::c_uint; 2usize],
    #[doc = " The pose of the origin captured during calibration."]
    #[doc = " Like all other poses here, this is expressed in the space set by ovr_RecenterTrackingOrigin,"]
    #[doc = " or ovr_SpecifyTrackingOrigin and so will change every time either of those functions are"]
    #[doc = " called. This pose can be used to calculate where the calibrated origin lands in the new"]
    #[doc = " recentered space. If an application never calls ovr_RecenterTrackingOrigin or"]
    #[doc = " ovr_SpecifyTrackingOrigin, expect this value to be the identity pose and as such will point"]
    #[doc = " respective origin based on ovrTrackingOrigin requested when calling ovr_GetTrackingState."]
    pub CalibratedOrigin: ovrPosef,
}
#[test]
fn bindgen_test_layout_ovrTrackingState_() {
    assert_eq!(
        ::std::mem::size_of::<ovrTrackingState_>(),
        312usize,
        concat!("Size of: ", stringify!(ovrTrackingState_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTrackingState_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrTrackingState_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTrackingState_>())).HeadPose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTrackingState_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTrackingState_>())).StatusFlags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTrackingState_),
            "::",
            stringify!(StatusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTrackingState_>())).HandPoses as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTrackingState_),
            "::",
            stringify!(HandPoses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTrackingState_>())).HandStatusFlags as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTrackingState_),
            "::",
            stringify!(HandStatusFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTrackingState_>())).CalibratedOrigin as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTrackingState_),
            "::",
            stringify!(CalibratedOrigin)
        )
    );
}
pub type ovrTrackingState = ovrTrackingState_;
#[doc = " Rendering information for each eye. Computed by ovr_GetRenderDesc() based on the"]
#[doc = " specified FOV. Note that the rendering viewport is not included"]
#[doc = " here as it can be specified separately and modified per frame by"]
#[doc = " passing different Viewport values in the layer structure."]
#[doc = ""]
#[doc = " \\see ovr_GetRenderDesc"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrEyeRenderDesc_ {
    #[doc = "< The eye index to which this instance corresponds."]
    pub Eye: ovrEyeType,
    #[doc = "< The field of view."]
    pub Fov: ovrFovPort,
    #[doc = "< Distortion viewport."]
    pub DistortedViewport: ovrRecti,
    #[doc = "< How many display pixels will fit in tan(angle) = 1."]
    pub PixelsPerTanAngleAtCenter: ovrVector2f,
    #[doc = "< Transform of eye from the HMD center, in meters."]
    pub HmdToEyePose: ovrPosef,
}
#[test]
fn bindgen_test_layout_ovrEyeRenderDesc_() {
    assert_eq!(
        ::std::mem::size_of::<ovrEyeRenderDesc_>(),
        72usize,
        concat!("Size of: ", stringify!(ovrEyeRenderDesc_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrEyeRenderDesc_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrEyeRenderDesc_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrEyeRenderDesc_>())).Eye as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEyeRenderDesc_),
            "::",
            stringify!(Eye)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrEyeRenderDesc_>())).Fov as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEyeRenderDesc_),
            "::",
            stringify!(Fov)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrEyeRenderDesc_>())).DistortedViewport as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEyeRenderDesc_),
            "::",
            stringify!(DistortedViewport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrEyeRenderDesc_>())).PixelsPerTanAngleAtCenter as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEyeRenderDesc_),
            "::",
            stringify!(PixelsPerTanAngleAtCenter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrEyeRenderDesc_>())).HmdToEyePose as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEyeRenderDesc_),
            "::",
            stringify!(HmdToEyePose)
        )
    );
}
pub type ovrEyeRenderDesc = ovrEyeRenderDesc_;
#[doc = " Projection information for ovrLayerEyeFovDepth."]
#[doc = ""]
#[doc = " Use the utility function ovrTimewarpProjectionDesc_FromProjection to"]
#[doc = " generate this structure from the application's projection matrix."]
#[doc = ""]
#[doc = " \\see ovrLayerEyeFovDepth, ovrTimewarpProjectionDesc_FromProjection"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrTimewarpProjectionDesc_ {
    #[doc = "< Projection matrix element [2][2]."]
    pub Projection22: f32,
    #[doc = "< Projection matrix element [2][3]."]
    pub Projection23: f32,
    #[doc = "< Projection matrix element [3][2]."]
    pub Projection32: f32,
}
#[test]
fn bindgen_test_layout_ovrTimewarpProjectionDesc_() {
    assert_eq!(
        ::std::mem::size_of::<ovrTimewarpProjectionDesc_>(),
        12usize,
        concat!("Size of: ", stringify!(ovrTimewarpProjectionDesc_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTimewarpProjectionDesc_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrTimewarpProjectionDesc_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTimewarpProjectionDesc_>())).Projection22 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTimewarpProjectionDesc_),
            "::",
            stringify!(Projection22)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTimewarpProjectionDesc_>())).Projection23 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTimewarpProjectionDesc_),
            "::",
            stringify!(Projection23)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTimewarpProjectionDesc_>())).Projection32 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTimewarpProjectionDesc_),
            "::",
            stringify!(Projection32)
        )
    );
}
pub type ovrTimewarpProjectionDesc = ovrTimewarpProjectionDesc_;
#[doc = " Contains the data necessary to properly calculate position info for various layer types."]
#[doc = " - HmdToEyePose is the same value-pair provided in ovrEyeRenderDesc. Modifying this value is"]
#[doc = "   suggested only if the app is forcing monoscopic rendering and requires that all layers"]
#[doc = "   including quad layers show up in a monoscopic fashion."]
#[doc = " - HmdSpaceToWorldScaleInMeters is used to scale player motion into in-application units."]
#[doc = "   In other words, it is how big an in-application unit is in the player's physical meters."]
#[doc = "   For example, if the application uses inches as its units then HmdSpaceToWorldScaleInMeters"]
#[doc = "   would be 0.0254."]
#[doc = "   Note that if you are scaling the player in size, this must also scale. So if your application"]
#[doc = "   units are inches, but you're shrinking the player to half their normal size, then"]
#[doc = "   HmdSpaceToWorldScaleInMeters would be 0.0254*2.0."]
#[doc = ""]
#[doc = " \\see ovrEyeRenderDesc, ovr_SubmitFrame"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrViewScaleDesc_ {
    #[doc = "< Transform of each eye from the HMD center, in meters."]
    pub HmdToEyePose: [ovrPosef; 2usize],
    #[doc = "< Ratio of viewer units to meter units."]
    pub HmdSpaceToWorldScaleInMeters: f32,
}
#[test]
fn bindgen_test_layout_ovrViewScaleDesc_() {
    assert_eq!(
        ::std::mem::size_of::<ovrViewScaleDesc_>(),
        60usize,
        concat!("Size of: ", stringify!(ovrViewScaleDesc_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrViewScaleDesc_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrViewScaleDesc_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrViewScaleDesc_>())).HmdToEyePose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrViewScaleDesc_),
            "::",
            stringify!(HmdToEyePose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrViewScaleDesc_>())).HmdSpaceToWorldScaleInMeters as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrViewScaleDesc_),
            "::",
            stringify!(HmdSpaceToWorldScaleInMeters)
        )
    );
}
pub type ovrViewScaleDesc = ovrViewScaleDesc_;
#[doc = "< 2D textures."]
pub const ovrTextureType__ovrTexture_2D: ovrTextureType_ = 0;
#[doc = "< Application-provided 2D texture. Not supported on PC."]
pub const ovrTextureType__ovrTexture_2D_External: ovrTextureType_ = 1;
#[doc = "< Cube maps. ovrTextureSwapChainDesc::ArraySize must be 6 for this type."]
pub const ovrTextureType__ovrTexture_Cube: ovrTextureType_ = 2;
pub const ovrTextureType__ovrTexture_Count: ovrTextureType_ = 3;
#[doc = "< \\internal Force type int32_t."]
pub const ovrTextureType__ovrTexture_EnumSize: ovrTextureType_ = 2147483647;
#[doc = " The type of texture resource."]
#[doc = ""]
#[doc = " \\see ovrTextureSwapChainDesc"]
#[doc = ""]
pub type ovrTextureType_ = i32;
pub use self::ovrTextureType_ as ovrTextureType;
pub const ovrTextureBindFlags__ovrTextureBind_None: ovrTextureBindFlags_ = 0;
#[doc = " The application can write into the chain with pixel shader."]
pub const ovrTextureBindFlags__ovrTextureBind_DX_RenderTarget: ovrTextureBindFlags_ = 1;
#[doc = " The application can write to the chain with compute shader."]
pub const ovrTextureBindFlags__ovrTextureBind_DX_UnorderedAccess: ovrTextureBindFlags_ = 2;
#[doc = " The chain buffers can be bound as depth and/or stencil buffers."]
#[doc = " This flag cannot be combined with ovrTextureBind_DX_RenderTarget."]
pub const ovrTextureBindFlags__ovrTextureBind_DX_DepthStencil: ovrTextureBindFlags_ = 4;
#[doc = "< \\internal Force type int32_t."]
pub const ovrTextureBindFlags__ovrTextureBind_EnumSize: ovrTextureBindFlags_ = 2147483647;
#[doc = " The bindings required for texture swap chain."]
#[doc = ""]
#[doc = " All texture swap chains are automatically bindable as shader"]
#[doc = " input resources since the Oculus runtime needs this to read them."]
#[doc = ""]
#[doc = " \\see ovrTextureSwapChainDesc"]
#[doc = ""]
pub type ovrTextureBindFlags_ = i32;
pub use self::ovrTextureBindFlags_ as ovrTextureBindFlags;
pub const ovrTextureFormat__OVR_FORMAT_UNKNOWN: ovrTextureFormat_ = 0;
#[doc = "< Not currently supported on PC. Requires a DirectX 11.1 device."]
pub const ovrTextureFormat__OVR_FORMAT_B5G6R5_UNORM: ovrTextureFormat_ = 1;
#[doc = "< Not currently supported on PC. Requires a DirectX 11.1 device."]
pub const ovrTextureFormat__OVR_FORMAT_B5G5R5A1_UNORM: ovrTextureFormat_ = 2;
#[doc = "< Not currently supported on PC. Requires a DirectX 11.1 device."]
pub const ovrTextureFormat__OVR_FORMAT_B4G4R4A4_UNORM: ovrTextureFormat_ = 3;
pub const ovrTextureFormat__OVR_FORMAT_R8G8B8A8_UNORM: ovrTextureFormat_ = 4;
pub const ovrTextureFormat__OVR_FORMAT_R8G8B8A8_UNORM_SRGB: ovrTextureFormat_ = 5;
pub const ovrTextureFormat__OVR_FORMAT_B8G8R8A8_UNORM: ovrTextureFormat_ = 6;
pub const ovrTextureFormat__OVR_FORMAT_B8G8R8_UNORM: ovrTextureFormat_ = 27;
#[doc = "< Not supported for OpenGL applications"]
pub const ovrTextureFormat__OVR_FORMAT_B8G8R8A8_UNORM_SRGB: ovrTextureFormat_ = 7;
#[doc = "< Not supported for OpenGL applications"]
pub const ovrTextureFormat__OVR_FORMAT_B8G8R8X8_UNORM: ovrTextureFormat_ = 8;
#[doc = "< Not supported for OpenGL applications"]
pub const ovrTextureFormat__OVR_FORMAT_B8G8R8X8_UNORM_SRGB: ovrTextureFormat_ = 9;
pub const ovrTextureFormat__OVR_FORMAT_R16G16B16A16_FLOAT: ovrTextureFormat_ = 10;
#[doc = "< Not supported for D3D12 applications. Introduced in v1.10"]
pub const ovrTextureFormat__OVR_FORMAT_R11G11B10_FLOAT: ovrTextureFormat_ = 25;
pub const ovrTextureFormat__OVR_FORMAT_D16_UNORM: ovrTextureFormat_ = 11;
pub const ovrTextureFormat__OVR_FORMAT_D24_UNORM_S8_UINT: ovrTextureFormat_ = 12;
pub const ovrTextureFormat__OVR_FORMAT_D32_FLOAT: ovrTextureFormat_ = 13;
pub const ovrTextureFormat__OVR_FORMAT_D32_FLOAT_S8X24_UINT: ovrTextureFormat_ = 14;
pub const ovrTextureFormat__OVR_FORMAT_BC1_UNORM: ovrTextureFormat_ = 15;
pub const ovrTextureFormat__OVR_FORMAT_BC1_UNORM_SRGB: ovrTextureFormat_ = 16;
pub const ovrTextureFormat__OVR_FORMAT_BC2_UNORM: ovrTextureFormat_ = 17;
pub const ovrTextureFormat__OVR_FORMAT_BC2_UNORM_SRGB: ovrTextureFormat_ = 18;
pub const ovrTextureFormat__OVR_FORMAT_BC3_UNORM: ovrTextureFormat_ = 19;
pub const ovrTextureFormat__OVR_FORMAT_BC3_UNORM_SRGB: ovrTextureFormat_ = 20;
pub const ovrTextureFormat__OVR_FORMAT_BC6H_UF16: ovrTextureFormat_ = 21;
pub const ovrTextureFormat__OVR_FORMAT_BC6H_SF16: ovrTextureFormat_ = 22;
pub const ovrTextureFormat__OVR_FORMAT_BC7_UNORM: ovrTextureFormat_ = 23;
pub const ovrTextureFormat__OVR_FORMAT_BC7_UNORM_SRGB: ovrTextureFormat_ = 24;
pub const ovrTextureFormat__OVR_FORMAT_LAST: ovrTextureFormat_ = 25;
#[doc = "< \\internal Force type int32_t."]
pub const ovrTextureFormat__OVR_FORMAT_ENUMSIZE: ovrTextureFormat_ = 2147483647;
#[doc = " The format of a texture."]
#[doc = ""]
#[doc = " \\see ovrTextureSwapChainDesc"]
#[doc = ""]
pub type ovrTextureFormat_ = i32;
pub use self::ovrTextureFormat_ as ovrTextureFormat;
pub const ovrTextureMiscFlags__ovrTextureMisc_None: ovrTextureMiscFlags_ = 0;
#[doc = " Vulkan and DX only: The underlying texture is created with a TYPELESS equivalent"]
#[doc = " of the format specified in the texture desc. The SDK will still access the"]
#[doc = " texture using the format specified in the texture desc, but the app can"]
#[doc = " create views with different formats if this is specified."]
pub const ovrTextureMiscFlags__ovrTextureMisc_DX_Typeless: ovrTextureMiscFlags_ = 1;
#[doc = " DX only: Allow generation of the mip chain on the GPU via the GenerateMips"]
#[doc = " call. This flag requires that RenderTarget binding also be specified."]
pub const ovrTextureMiscFlags__ovrTextureMisc_AllowGenerateMips: ovrTextureMiscFlags_ = 2;
#[doc = " Texture swap chain contains protected content, and requires"]
#[doc = " HDCP connection in order to display to HMD. Also prevents"]
#[doc = " mirroring or other redirection of any frame containing this contents"]
pub const ovrTextureMiscFlags__ovrTextureMisc_ProtectedContent: ovrTextureMiscFlags_ = 4;
#[doc = " Automatically generate and use the mip chain in composition on each submission."]
#[doc = " Mips are regenerated from highest quality level, ignoring other pre-existing mip levels."]
#[doc = " Not supported for depth or compressed (BC) formats."]
pub const ovrTextureMiscFlags__ovrTextureMisc_AutoGenerateMips: ovrTextureMiscFlags_ = 8;
#[doc = "< \\internal Force type int32_t."]
pub const ovrTextureMiscFlags__ovrTextureMisc_EnumSize: ovrTextureMiscFlags_ = 2147483647;
#[doc = " Misc flags overriding particular"]
#[doc = "   behaviors of a texture swap chain"]
#[doc = ""]
#[doc = " \\see ovrTextureSwapChainDesc"]
#[doc = ""]
pub type ovrTextureMiscFlags_ = i32;
pub use self::ovrTextureMiscFlags_ as ovrTextureFlags;
#[doc = " Description used to create a texture swap chain."]
#[doc = ""]
#[doc = " \\see ovr_CreateTextureSwapChainDX"]
#[doc = " \\see ovr_CreateTextureSwapChainGL"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrTextureSwapChainDesc_ {
    #[doc = "< Must be ovrTexture_2D"]
    pub Type: ovrTextureType,
    pub Format: ovrTextureFormat,
    #[doc = "< Must be 6 for ovrTexture_Cube, 1 for other types."]
    pub ArraySize: ::std::os::raw::c_int,
    pub Width: ::std::os::raw::c_int,
    pub Height: ::std::os::raw::c_int,
    pub MipLevels: ::std::os::raw::c_int,
    pub SampleCount: ::std::os::raw::c_int,
    #[doc = "< Not buffered in a chain. For images that don't change"]
    pub StaticImage: ovrBool,
    #[doc = "< ovrTextureFlags"]
    pub MiscFlags: ::std::os::raw::c_uint,
    #[doc = "< ovrTextureBindFlags. Not used for GL."]
    pub BindFlags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ovrTextureSwapChainDesc_() {
    assert_eq!(
        ::std::mem::size_of::<ovrTextureSwapChainDesc_>(),
        40usize,
        concat!("Size of: ", stringify!(ovrTextureSwapChainDesc_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTextureSwapChainDesc_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrTextureSwapChainDesc_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTextureSwapChainDesc_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureSwapChainDesc_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTextureSwapChainDesc_>())).Format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureSwapChainDesc_),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureSwapChainDesc_>())).ArraySize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureSwapChainDesc_),
            "::",
            stringify!(ArraySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTextureSwapChainDesc_>())).Width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureSwapChainDesc_),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTextureSwapChainDesc_>())).Height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureSwapChainDesc_),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureSwapChainDesc_>())).MipLevels as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureSwapChainDesc_),
            "::",
            stringify!(MipLevels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureSwapChainDesc_>())).SampleCount as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureSwapChainDesc_),
            "::",
            stringify!(SampleCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureSwapChainDesc_>())).StaticImage as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureSwapChainDesc_),
            "::",
            stringify!(StaticImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureSwapChainDesc_>())).MiscFlags as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureSwapChainDesc_),
            "::",
            stringify!(MiscFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureSwapChainDesc_>())).BindFlags as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureSwapChainDesc_),
            "::",
            stringify!(BindFlags)
        )
    );
}
pub type ovrTextureSwapChainDesc = ovrTextureSwapChainDesc_;
#[doc = " By default the mirror texture will be:"]
#[doc = " * Pre-distortion (i.e. rectilinear)"]
#[doc = " * Contain both eye textures"]
#[doc = " * Exclude Guardian, Notifications, System Menu GUI"]
pub const ovrMirrorOptions__ovrMirrorOption_Default: ovrMirrorOptions_ = 0;
#[doc = " Retrieves the barrel distorted texture contents instead of the rectilinear one"]
#[doc = " This is only recommended for debugging purposes, and not for final desktop presentation"]
pub const ovrMirrorOptions__ovrMirrorOption_PostDistortion: ovrMirrorOptions_ = 1;
#[doc = " Since ovrMirrorOption_Default renders both eyes into the mirror texture,"]
#[doc = " these two flags are exclusive (i.e. cannot use them simultaneously)"]
pub const ovrMirrorOptions__ovrMirrorOption_LeftEyeOnly: ovrMirrorOptions_ = 2;
#[doc = " Since ovrMirrorOption_Default renders both eyes into the mirror texture,"]
#[doc = " these two flags are exclusive (i.e. cannot use them simultaneously)"]
pub const ovrMirrorOptions__ovrMirrorOption_RightEyeOnly: ovrMirrorOptions_ = 4;
#[doc = " Shows the boundary system aka Guardian on the mirror texture"]
pub const ovrMirrorOptions__ovrMirrorOption_IncludeGuardian: ovrMirrorOptions_ = 8;
#[doc = " Shows system notifications the user receives on the mirror texture"]
pub const ovrMirrorOptions__ovrMirrorOption_IncludeNotifications: ovrMirrorOptions_ = 16;
#[doc = " Shows the system menu (triggered by hitting the Home button) on the mirror texture"]
pub const ovrMirrorOptions__ovrMirrorOption_IncludeSystemGui: ovrMirrorOptions_ = 32;
#[doc = " Forces mirror output to use max symmetric FOV instead of asymmetric full FOV used by HMD."]
#[doc = " Only valid for rectilinear mirrors i.e. using ovrMirrorOption_PostDistortion with"]
#[doc = " ovrMirrorOption_ForceSymmetricFov will result in ovrError_InvalidParameter error."]
pub const ovrMirrorOptions__ovrMirrorOption_ForceSymmetricFov: ovrMirrorOptions_ = 64;
#[doc = "< \\internal Force type int32_t."]
pub const ovrMirrorOptions__ovrMirrorOption_EnumSize: ovrMirrorOptions_ = 2147483647;
#[doc = " Bit flags used as part of ovrMirrorTextureDesc's MirrorOptions field."]
#[doc = ""]
#[doc = " \\see ovr_CreateMirrorTextureWithOptionsDX"]
#[doc = " \\see ovr_CreateMirrorTextureWithOptionsGL"]
#[doc = " \\see ovr_CreateMirrorTextureWithOptionsVk"]
#[doc = ""]
pub type ovrMirrorOptions_ = i32;
pub use self::ovrMirrorOptions_ as ovrMirrorOptions;
#[doc = " Description used to create a mirror texture."]
#[doc = ""]
#[doc = " \\see ovr_CreateMirrorTextureWithOptionsDX"]
#[doc = " \\see ovr_CreateMirrorTextureWithOptionsGL"]
#[doc = " \\see ovr_CreateMirrorTextureWithOptionsVk"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrMirrorTextureDesc_ {
    pub Format: ovrTextureFormat,
    pub Width: ::std::os::raw::c_int,
    pub Height: ::std::os::raw::c_int,
    #[doc = "< ovrTextureFlags"]
    pub MiscFlags: ::std::os::raw::c_uint,
    #[doc = "< ovrMirrorOptions"]
    pub MirrorOptions: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ovrMirrorTextureDesc_() {
    assert_eq!(
        ::std::mem::size_of::<ovrMirrorTextureDesc_>(),
        20usize,
        concat!("Size of: ", stringify!(ovrMirrorTextureDesc_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrMirrorTextureDesc_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrMirrorTextureDesc_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrMirrorTextureDesc_>())).Format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrMirrorTextureDesc_),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrMirrorTextureDesc_>())).Width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrMirrorTextureDesc_),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrMirrorTextureDesc_>())).Height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrMirrorTextureDesc_),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrMirrorTextureDesc_>())).MiscFlags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrMirrorTextureDesc_),
            "::",
            stringify!(MiscFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrMirrorTextureDesc_>())).MirrorOptions as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrMirrorTextureDesc_),
            "::",
            stringify!(MirrorOptions)
        )
    );
}
pub type ovrMirrorTextureDesc = ovrMirrorTextureDesc_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrTextureSwapChainData {
    _unused: [u8; 0],
}
pub type ovrTextureSwapChain = *mut ovrTextureSwapChainData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrMirrorTextureData {
    _unused: [u8; 0],
}
pub type ovrMirrorTexture = *mut ovrMirrorTextureData;
#[doc = "< Triangle list covering parts that are hidden to users"]
pub const ovrFovStencilType__ovrFovStencil_HiddenArea: ovrFovStencilType_ = 0;
#[doc = "< Triangle list covering parts that are visible to users"]
pub const ovrFovStencilType__ovrFovStencil_VisibleArea: ovrFovStencilType_ = 1;
#[doc = "< Line list that draws the boundary visible to users"]
pub const ovrFovStencilType__ovrFovStencil_BorderLine: ovrFovStencilType_ = 2;
#[doc = "< Axis-aligned rectangle fit in visible region"]
#[doc = "< 4x vertices: TopLeft, TopRight, BottomRight, BottomLeft"]
pub const ovrFovStencilType__ovrFovStencil_VisibleRectangle: ovrFovStencilType_ = 3;
#[doc = "< \\internal Force type int32_t."]
pub const ovrFovStencilType__ovrFovStencilType_EnumSize: ovrFovStencilType_ = 2147483647;
#[doc = " Viewport stencil types provided by the ovr_GetFovStencil call."]
#[doc = " \\see ovr_GetFovStencil"]
pub type ovrFovStencilType_ = i32;
pub use self::ovrFovStencilType_ as ovrFovStencilType;
#[doc = " When used, flips the Y component of the provided 2D mesh coordinates, such that Y increases"]
#[doc = " upwards. When not used, places mesh origin at top-left where Y increases downwards."]
pub const ovrFovStencilFlags__ovrFovStencilFlag_MeshOriginAtBottomLeft: ovrFovStencilFlags_ = 1;
#[doc = "< \\internal Force type int32_t."]
pub const ovrFovStencilFlags__ovrFovStencilFlag_EnumSize: ovrFovStencilFlags_ = 2147483647;
#[doc = " Identifies flags used by ovrFovStencilDesc and which are passed to ovr_GetFovStencil."]
#[doc = " \\see ovrFovStencilDesc"]
pub type ovrFovStencilFlags_ = i32;
pub use self::ovrFovStencilFlags_ as ovrFovStencilFlags;
#[doc = " Fov-stencil mesh descriptor passed into the function ovr_GetFovStencil"]
#[doc = " \\see ovr_GetFovStencil"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ovrFovStencilDesc_ {
    pub StencilType: ovrFovStencilType,
    #[doc = "< Bit flag combination of ovrFovStencilFlags"]
    pub StencilFlags: u32,
    pub Eye: ovrEyeType,
    #[doc = "< Typically FOV obtained from ovrEyeRenderDesc"]
    pub FovPort: ovrFovPort,
    #[doc = "< Typically HmdToEyePose.Orientation obtained from ovrEyeRenderDesc"]
    #[doc = "< Note: Currently unsupported, always treated as identity"]
    pub HmdToEyeRotation: ovrQuatf,
}
#[test]
fn bindgen_test_layout_ovrFovStencilDesc_() {
    assert_eq!(
        ::std::mem::size_of::<ovrFovStencilDesc_>(),
        48usize,
        concat!("Size of: ", stringify!(ovrFovStencilDesc_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrFovStencilDesc_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrFovStencilDesc_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFovStencilDesc_>())).StencilType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovStencilDesc_),
            "::",
            stringify!(StencilType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFovStencilDesc_>())).StencilFlags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovStencilDesc_),
            "::",
            stringify!(StencilFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFovStencilDesc_>())).Eye as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovStencilDesc_),
            "::",
            stringify!(Eye)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFovStencilDesc_>())).FovPort as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovStencilDesc_),
            "::",
            stringify!(FovPort)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFovStencilDesc_>())).HmdToEyeRotation as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovStencilDesc_),
            "::",
            stringify!(HmdToEyeRotation)
        )
    );
}
pub type ovrFovStencilDesc = ovrFovStencilDesc_;
#[doc = " Contains the data for the fov-stencil mesh. Parts of the struct are filled by the caller"]
#[doc = " while some parts are filled by the SDK."]
#[doc = " \\see ovr_GetFovStencil"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrFovStencilMeshBuffer_ {
    #[doc = "< To be filled in by caller of ovr_GetFovStencil"]
    pub AllocVertexCount: ::std::os::raw::c_int,
    #[doc = "< To be filled in by SDK and returned to caller"]
    pub UsedVertexCount: ::std::os::raw::c_int,
    #[doc = "< To be allocated by caller and filled in by SDK"]
    pub VertexBuffer: *mut ovrVector2f,
    #[doc = "< To be filled in by caller of ovr_GetFovStencil"]
    pub AllocIndexCount: ::std::os::raw::c_int,
    #[doc = "< To be filled in by SDK and returned to caller"]
    pub UsedIndexCount: ::std::os::raw::c_int,
    #[doc = "< To be allocated by caller and filled in by SDK"]
    pub IndexBuffer: *mut u16,
}
#[test]
fn bindgen_test_layout_ovrFovStencilMeshBuffer_() {
    assert_eq!(
        ::std::mem::size_of::<ovrFovStencilMeshBuffer_>(),
        32usize,
        concat!("Size of: ", stringify!(ovrFovStencilMeshBuffer_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrFovStencilMeshBuffer_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrFovStencilMeshBuffer_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFovStencilMeshBuffer_>())).AllocVertexCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovStencilMeshBuffer_),
            "::",
            stringify!(AllocVertexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFovStencilMeshBuffer_>())).UsedVertexCount as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovStencilMeshBuffer_),
            "::",
            stringify!(UsedVertexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFovStencilMeshBuffer_>())).VertexBuffer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovStencilMeshBuffer_),
            "::",
            stringify!(VertexBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFovStencilMeshBuffer_>())).AllocIndexCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovStencilMeshBuffer_),
            "::",
            stringify!(AllocIndexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFovStencilMeshBuffer_>())).UsedIndexCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovStencilMeshBuffer_),
            "::",
            stringify!(UsedIndexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFovStencilMeshBuffer_>())).IndexBuffer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFovStencilMeshBuffer_),
            "::",
            stringify!(IndexBuffer)
        )
    );
}
pub type ovrFovStencilMeshBuffer = ovrFovStencilMeshBuffer_;
extern "C" {
    #[doc = " Returns a viewport stencil mesh to be used for defining the area or outline the user"]
    #[doc = " can see through the lens on an area defined by a given ovrFovPort."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] fovStencilDesc Info provided by caller necessary to generate a stencil mesh."]
    #[doc = " \\param[in] meshBuffer Mesh buffer to be partially filled in and returned by the SDK."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of"]
    #[doc = "         failure, use ovr_GetLastErrorInfo to get more information."]
    #[doc = "         Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: Completed successfully."]
    #[doc = "     - ovrError_ServiceConnection: The service connection was lost and the application"]
    #[doc = "       must destroy the session."]
    #[doc = "     - ovrError_InvalidParameter: One or more of the parameters"]
    #[doc = ""]
    #[doc = " To find out how big the vertex and index buffers in meshBuffer buffer should be, first call"]
    #[doc = " this function setting AllocVertexCount & AllocIndexCount to 0 while also sending in nullptr"]
    #[doc = " for VertexBuffer & IndexBuffer. The SDK will populate UsedVertexCount & UsedIndexCount values."]
    #[doc = ""]
    #[doc = " If Alloc*Count fields in meshBuffer are smaller than the expected Used*Count fields,"]
    #[doc = " (except when they are 0) then the SDK will return ovrError_InvalidParameter and leave"]
    #[doc = " VertexBuffer and IndexBuffer untouched."]
    #[doc = ""]
    #[doc = " 2D positions provided in the buffer will be in the [0,1] range where Y increases downward,"]
    #[doc = " similar to texture-UV space. If Y coordinates need to be flipped upside down, use the"]
    #[doc = " ovrFovStencilFlag_MeshOriginAtBottomLeft."]
    #[doc = ""]
    pub fn ovr_GetFovStencil(
        session: ovrSession,
        fovStencilDesc: *const ovrFovStencilDesc,
        meshBuffer: *mut ovrFovStencilMeshBuffer,
    ) -> ovrResult;
}
#[doc = " A button on XBox controllers and right Touch controller. Not present on Oculus Remote."]
pub const ovrButton__ovrButton_A: ovrButton_ = 1;
#[doc = " B button on XBox controllers and right Touch controller. Not present on Oculus Remote."]
pub const ovrButton__ovrButton_B: ovrButton_ = 2;
#[doc = " Right thumbstick on XBox controllers and Touch controllers. Not present on Oculus Remote."]
pub const ovrButton__ovrButton_RThumb: ovrButton_ = 4;
#[doc = " Right shoulder button on XBox controllers. Not present on Touch controllers or Oculus Remote."]
pub const ovrButton__ovrButton_RShoulder: ovrButton_ = 8;
#[doc = " X button on XBox controllers and left Touch controller. Not present on Oculus Remote."]
pub const ovrButton__ovrButton_X: ovrButton_ = 256;
#[doc = " Y button on XBox controllers and left Touch controller. Not present on Oculus Remote."]
pub const ovrButton__ovrButton_Y: ovrButton_ = 512;
#[doc = " Left thumbstick on XBox controllers and Touch controllers. Not present on Oculus Remote."]
pub const ovrButton__ovrButton_LThumb: ovrButton_ = 1024;
#[doc = " Left shoulder button on XBox controllers. Not present on Touch controllers or Oculus Remote."]
pub const ovrButton__ovrButton_LShoulder: ovrButton_ = 2048;
#[doc = " Up button on XBox controllers and Oculus Remote. Not present on Touch controllers."]
pub const ovrButton__ovrButton_Up: ovrButton_ = 65536;
#[doc = " Down button on XBox controllers and Oculus Remote. Not present on Touch controllers."]
pub const ovrButton__ovrButton_Down: ovrButton_ = 131072;
#[doc = " Left button on XBox controllers and Oculus Remote. Not present on Touch controllers."]
pub const ovrButton__ovrButton_Left: ovrButton_ = 262144;
#[doc = " Right button on XBox controllers and Oculus Remote. Not present on Touch controllers."]
pub const ovrButton__ovrButton_Right: ovrButton_ = 524288;
#[doc = " Start on XBox 360 controller. Menu on XBox One controller and Left Touch controller."]
#[doc = " Select button on Oculus Remote."]
#[doc = " Should be referred to as the Menu button in user-facing documentation."]
pub const ovrButton__ovrButton_Enter: ovrButton_ = 1048576;
#[doc = " Back on Xbox 360 controller and Oculus Remote. View button on XBox One controller."]
#[doc = " Not present on Touch controllers."]
pub const ovrButton__ovrButton_Back: ovrButton_ = 2097152;
#[doc = " Volume button on Oculus Remote. Not present on XBox or Touch controllers."]
pub const ovrButton__ovrButton_VolUp: ovrButton_ = 4194304;
#[doc = " Volume button on Oculus Remote. Not present on XBox or Touch controllers."]
pub const ovrButton__ovrButton_VolDown: ovrButton_ = 8388608;
#[doc = " Home button on XBox controllers. Oculus button on Touch controllers and Oculus Remote."]
pub const ovrButton__ovrButton_Home: ovrButton_ = 16777216;
#[doc = " Home button on XBox controllers. Oculus button on Touch controllers and Oculus Remote."]
pub const ovrButton__ovrButton_Private: ovrButton_ = 29360128;
#[doc = " Home button on XBox controllers. Oculus button on Touch controllers and Oculus Remote."]
pub const ovrButton__ovrButton_RMask: ovrButton_ = 15;
#[doc = " Home button on XBox controllers. Oculus button on Touch controllers and Oculus Remote."]
pub const ovrButton__ovrButton_LMask: ovrButton_ = 1052416;
#[doc = "< \\internal Force type int32_t."]
pub const ovrButton__ovrButton_EnumSize: ovrButton_ = 2147483647;
#[doc = " Describes button input types."]
#[doc = " Button inputs are combined; that is they will be reported as pressed if they are"]
#[doc = " pressed on either one of the two devices."]
#[doc = " The ovrButton_Up/Down/Left/Right map to both XBox D-Pad and directional buttons."]
#[doc = " The ovrButton_Enter and ovrButton_Return map to Start and Back controller buttons, respectively."]
pub type ovrButton_ = i32;
pub use self::ovrButton_ as ovrButton;
pub const ovrTouch__ovrTouch_A: ovrTouch_ = 1;
pub const ovrTouch__ovrTouch_B: ovrTouch_ = 2;
pub const ovrTouch__ovrTouch_RThumb: ovrTouch_ = 4;
pub const ovrTouch__ovrTouch_RThumbRest: ovrTouch_ = 8;
pub const ovrTouch__ovrTouch_RIndexTrigger: ovrTouch_ = 16;
pub const ovrTouch__ovrTouch_RButtonMask: ovrTouch_ = 31;
pub const ovrTouch__ovrTouch_X: ovrTouch_ = 256;
pub const ovrTouch__ovrTouch_Y: ovrTouch_ = 512;
pub const ovrTouch__ovrTouch_LThumb: ovrTouch_ = 1024;
pub const ovrTouch__ovrTouch_LThumbRest: ovrTouch_ = 2048;
pub const ovrTouch__ovrTouch_LIndexTrigger: ovrTouch_ = 4096;
pub const ovrTouch__ovrTouch_LButtonMask: ovrTouch_ = 7936;
pub const ovrTouch__ovrTouch_RIndexPointing: ovrTouch_ = 32;
pub const ovrTouch__ovrTouch_RThumbUp: ovrTouch_ = 64;
pub const ovrTouch__ovrTouch_LIndexPointing: ovrTouch_ = 8192;
pub const ovrTouch__ovrTouch_LThumbUp: ovrTouch_ = 16384;
pub const ovrTouch__ovrTouch_RPoseMask: ovrTouch_ = 96;
pub const ovrTouch__ovrTouch_LPoseMask: ovrTouch_ = 24576;
#[doc = "< \\internal Force type int32_t."]
pub const ovrTouch__ovrTouch_EnumSize: ovrTouch_ = 2147483647;
#[doc = " Describes touch input types."]
#[doc = " These values map to capacitive touch values reported ovrInputState::Touch."]
#[doc = " Some of these values are mapped to button bits for consistency."]
pub type ovrTouch_ = i32;
pub use self::ovrTouch_ as ovrTouch;
#[doc = " Describes the Touch Haptics engine."]
#[doc = " Currently, those values will NOT change during a session."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ovrTouchHapticsDesc_ {
    pub SampleRateHz: ::std::os::raw::c_int,
    pub SampleSizeInBytes: ::std::os::raw::c_int,
    pub QueueMinSizeToAvoidStarvation: ::std::os::raw::c_int,
    pub SubmitMinSamples: ::std::os::raw::c_int,
    pub SubmitMaxSamples: ::std::os::raw::c_int,
    pub SubmitOptimalSamples: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrTouchHapticsDesc_() {
    assert_eq!(
        ::std::mem::size_of::<ovrTouchHapticsDesc_>(),
        24usize,
        concat!("Size of: ", stringify!(ovrTouchHapticsDesc_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTouchHapticsDesc_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrTouchHapticsDesc_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTouchHapticsDesc_>())).SampleRateHz as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTouchHapticsDesc_),
            "::",
            stringify!(SampleRateHz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTouchHapticsDesc_>())).SampleSizeInBytes as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTouchHapticsDesc_),
            "::",
            stringify!(SampleSizeInBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTouchHapticsDesc_>())).QueueMinSizeToAvoidStarvation
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTouchHapticsDesc_),
            "::",
            stringify!(QueueMinSizeToAvoidStarvation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTouchHapticsDesc_>())).SubmitMinSamples as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTouchHapticsDesc_),
            "::",
            stringify!(SubmitMinSamples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTouchHapticsDesc_>())).SubmitMaxSamples as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTouchHapticsDesc_),
            "::",
            stringify!(SubmitMaxSamples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTouchHapticsDesc_>())).SubmitOptimalSamples as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTouchHapticsDesc_),
            "::",
            stringify!(SubmitOptimalSamples)
        )
    );
}
pub type ovrTouchHapticsDesc = ovrTouchHapticsDesc_;
pub const ovrControllerType__ovrControllerType_None: ovrControllerType_ = 0;
pub const ovrControllerType__ovrControllerType_LTouch: ovrControllerType_ = 1;
pub const ovrControllerType__ovrControllerType_RTouch: ovrControllerType_ = 2;
pub const ovrControllerType__ovrControllerType_Touch: ovrControllerType_ = 3;
pub const ovrControllerType__ovrControllerType_Remote: ovrControllerType_ = 4;
pub const ovrControllerType__ovrControllerType_XBox: ovrControllerType_ = 16;
pub const ovrControllerType__ovrControllerType_Object0: ovrControllerType_ = 256;
pub const ovrControllerType__ovrControllerType_Object1: ovrControllerType_ = 512;
pub const ovrControllerType__ovrControllerType_Object2: ovrControllerType_ = 1024;
pub const ovrControllerType__ovrControllerType_Object3: ovrControllerType_ = 2048;
#[doc = "< Operate on or query whichever controller is active."]
pub const ovrControllerType__ovrControllerType_Active: ovrControllerType_ = -1;
#[doc = "< \\internal Force type int32_t."]
pub const ovrControllerType__ovrControllerType_EnumSize: ovrControllerType_ = 2147483647;
#[doc = " Specifies which controller is connected; multiple can be connected at once."]
pub type ovrControllerType_ = i32;
pub use self::ovrControllerType_ as ovrControllerType;
#[doc = " Enqueue buffer for later playback"]
pub const ovrHapticsBufferSubmitMode__ovrHapticsBufferSubmit_Enqueue: ovrHapticsBufferSubmitMode_ =
    0;
#[doc = " Haptics buffer submit mode"]
pub type ovrHapticsBufferSubmitMode_ = i32;
pub use self::ovrHapticsBufferSubmitMode_ as ovrHapticsBufferSubmitMode;
#[doc = " Haptics buffer descriptor, contains amplitude samples used for Touch vibration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrHapticsBuffer_ {
    #[doc = " Samples stored in opaque format"]
    pub Samples: *const ::std::os::raw::c_void,
    #[doc = " Number of samples (up to OVR_HAPTICS_BUFFER_SAMPLES_MAX)"]
    pub SamplesCount: ::std::os::raw::c_int,
    #[doc = " How samples are submitted to the hardware"]
    pub SubmitMode: ovrHapticsBufferSubmitMode,
}
#[test]
fn bindgen_test_layout_ovrHapticsBuffer_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHapticsBuffer_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrHapticsBuffer_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHapticsBuffer_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrHapticsBuffer_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticsBuffer_>())).Samples as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticsBuffer_),
            "::",
            stringify!(Samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticsBuffer_>())).SamplesCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticsBuffer_),
            "::",
            stringify!(SamplesCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticsBuffer_>())).SubmitMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticsBuffer_),
            "::",
            stringify!(SubmitMode)
        )
    );
}
pub type ovrHapticsBuffer = ovrHapticsBuffer_;
#[doc = " State of the Haptics playback for Touch vibration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrHapticsPlaybackState_ {
    pub RemainingQueueSpace: ::std::os::raw::c_int,
    pub SamplesQueued: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrHapticsPlaybackState_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHapticsPlaybackState_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrHapticsPlaybackState_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHapticsPlaybackState_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrHapticsPlaybackState_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrHapticsPlaybackState_>())).RemainingQueueSpace as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticsPlaybackState_),
            "::",
            stringify!(RemainingQueueSpace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrHapticsPlaybackState_>())).SamplesQueued as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticsPlaybackState_),
            "::",
            stringify!(SamplesQueued)
        )
    );
}
pub type ovrHapticsPlaybackState = ovrHapticsPlaybackState_;
pub const ovrTrackedDeviceType__ovrTrackedDevice_None: ovrTrackedDeviceType_ = 0;
pub const ovrTrackedDeviceType__ovrTrackedDevice_HMD: ovrTrackedDeviceType_ = 1;
pub const ovrTrackedDeviceType__ovrTrackedDevice_LTouch: ovrTrackedDeviceType_ = 2;
pub const ovrTrackedDeviceType__ovrTrackedDevice_RTouch: ovrTrackedDeviceType_ = 4;
pub const ovrTrackedDeviceType__ovrTrackedDevice_Touch: ovrTrackedDeviceType_ = 6;
pub const ovrTrackedDeviceType__ovrTrackedDevice_Object0: ovrTrackedDeviceType_ = 16;
pub const ovrTrackedDeviceType__ovrTrackedDevice_Object1: ovrTrackedDeviceType_ = 32;
pub const ovrTrackedDeviceType__ovrTrackedDevice_Object2: ovrTrackedDeviceType_ = 64;
pub const ovrTrackedDeviceType__ovrTrackedDevice_Object3: ovrTrackedDeviceType_ = 128;
pub const ovrTrackedDeviceType__ovrTrackedDevice_All: ovrTrackedDeviceType_ = 65535;
#[doc = " Position tracked devices"]
pub type ovrTrackedDeviceType_ = i32;
pub use self::ovrTrackedDeviceType_ as ovrTrackedDeviceType;
#[doc = " Outer boundary - closely represents user setup walls"]
pub const ovrBoundaryType__ovrBoundary_Outer: ovrBoundaryType_ = 1;
#[doc = " Play area - safe rectangular area inside outer boundary which can optionally be used to"]
#[doc = " restrict user interactions and motion."]
pub const ovrBoundaryType__ovrBoundary_PlayArea: ovrBoundaryType_ = 256;
#[doc = " Boundary types that specified while using the boundary system"]
pub type ovrBoundaryType_ = i32;
pub use self::ovrBoundaryType_ as ovrBoundaryType;
#[doc = " Boundary system look and feel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrBoundaryLookAndFeel_ {
    #[doc = " Boundary color (alpha channel is ignored)"]
    pub Color: ovrColorf,
}
#[test]
fn bindgen_test_layout_ovrBoundaryLookAndFeel_() {
    assert_eq!(
        ::std::mem::size_of::<ovrBoundaryLookAndFeel_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrBoundaryLookAndFeel_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrBoundaryLookAndFeel_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrBoundaryLookAndFeel_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrBoundaryLookAndFeel_>())).Color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryLookAndFeel_),
            "::",
            stringify!(Color)
        )
    );
}
pub type ovrBoundaryLookAndFeel = ovrBoundaryLookAndFeel_;
#[doc = " Provides boundary test information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrBoundaryTestResult_ {
    #[doc = " True if the boundary system is being triggered. Note that due to fade in/out effects this may"]
    #[doc = " not exactly match visibility."]
    pub IsTriggering: ovrBool,
    #[doc = " Distance to the closest play area or outer boundary surface."]
    pub ClosestDistance: f32,
    #[doc = " Closest point on the boundary surface."]
    pub ClosestPoint: ovrVector3f,
    #[doc = " Unit surface normal of the closest boundary surface."]
    pub ClosestPointNormal: ovrVector3f,
}
#[test]
fn bindgen_test_layout_ovrBoundaryTestResult_() {
    assert_eq!(
        ::std::mem::size_of::<ovrBoundaryTestResult_>(),
        32usize,
        concat!("Size of: ", stringify!(ovrBoundaryTestResult_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrBoundaryTestResult_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrBoundaryTestResult_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTestResult_>())).IsTriggering as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTestResult_),
            "::",
            stringify!(IsTriggering)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTestResult_>())).ClosestDistance as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTestResult_),
            "::",
            stringify!(ClosestDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTestResult_>())).ClosestPoint as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTestResult_),
            "::",
            stringify!(ClosestPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTestResult_>())).ClosestPointNormal as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTestResult_),
            "::",
            stringify!(ClosestPointNormal)
        )
    );
}
pub type ovrBoundaryTestResult = ovrBoundaryTestResult_;
pub const ovrHandType__ovrHand_Left: ovrHandType_ = 0;
pub const ovrHandType__ovrHand_Right: ovrHandType_ = 1;
pub const ovrHandType__ovrHand_Count: ovrHandType_ = 2;
#[doc = "< \\internal Force type int32_t."]
pub const ovrHandType__ovrHand_EnumSize: ovrHandType_ = 2147483647;
#[doc = " Provides names for the left and right hand array indexes."]
#[doc = ""]
#[doc = " \\see ovrInputState, ovrTrackingState"]
#[doc = ""]
pub type ovrHandType_ = i32;
pub use self::ovrHandType_ as ovrHandType;
#[doc = " ovrInputState describes the complete controller input state, including Oculus Touch,"]
#[doc = " and XBox gamepad. If multiple inputs are connected and used at the same time,"]
#[doc = " their inputs are combined."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputState_ {
    #[doc = " System type when the controller state was last updated."]
    pub TimeInSeconds: f64,
    #[doc = " Values for buttons described by ovrButton."]
    pub Buttons: ::std::os::raw::c_uint,
    #[doc = " Touch values for buttons and sensors as described by ovrTouch."]
    pub Touches: ::std::os::raw::c_uint,
    #[doc = " Left and right finger trigger values (ovrHand_Left and ovrHand_Right), in range 0.0 to 1.0f."]
    #[doc = " Returns 0 if the value would otherwise be less than 0.1176, for ovrControllerType_XBox."]
    #[doc = " This has been formally named simply \"Trigger\". We retain the name IndexTrigger for backwards"]
    #[doc = " code compatibility."]
    #[doc = " User-facing documentation should refer to it as the Trigger."]
    pub IndexTrigger: [f32; 2usize],
    #[doc = " Left and right hand trigger values (ovrHand_Left and ovrHand_Right), in the range 0.0 to 1.0f."]
    #[doc = " This has been formally named \"Grip Button\". We retain the name HandTrigger for backwards code"]
    #[doc = " compatibility."]
    #[doc = " User-facing documentation should refer to it as the Grip Button or simply Grip."]
    pub HandTrigger: [f32; 2usize],
    #[doc = " Horizontal and vertical thumbstick axis values (ovrHand_Left and ovrHand_Right), in the range"]
    #[doc = " of -1.0f to 1.0f."]
    #[doc = " Returns a deadzone (value 0) per each axis if the value on that axis would otherwise have been"]
    #[doc = " between -.2746 to +.2746, for ovrControllerType_XBox"]
    pub Thumbstick: [ovrVector2f; 2usize],
    #[doc = " The type of the controller this state is for."]
    pub ControllerType: ovrControllerType,
    #[doc = " Left and right finger trigger values (ovrHand_Left and ovrHand_Right), in range 0.0 to 1.0f."]
    #[doc = " Does not apply a deadzone.  Only touch applies a filter."]
    #[doc = " This has been formally named simply \"Trigger\". We retain the name IndexTrigger for backwards"]
    #[doc = " code compatibility."]
    #[doc = " User-facing documentation should refer to it as the Trigger."]
    pub IndexTriggerNoDeadzone: [f32; 2usize],
    #[doc = " Left and right hand trigger values (ovrHand_Left and ovrHand_Right), in the range 0.0 to 1.0f."]
    #[doc = " Does not apply a deadzone. Only touch applies a filter."]
    #[doc = " This has been formally named \"Grip Button\". We retain the name HandTrigger for backwards code"]
    #[doc = " compatibility."]
    #[doc = " User-facing documentation should refer to it as the Grip Button or simply Grip."]
    pub HandTriggerNoDeadzone: [f32; 2usize],
    #[doc = " Horizontal and vertical thumbstick axis values (ovrHand_Left and ovrHand_Right), in the range"]
    #[doc = " -1.0f to 1.0f"]
    #[doc = " Does not apply a deadzone or filter."]
    pub ThumbstickNoDeadzone: [ovrVector2f; 2usize],
    #[doc = " Left and right finger trigger values (ovrHand_Left and ovrHand_Right), in range 0.0 to 1.0f."]
    #[doc = " No deadzone or filter"]
    #[doc = " This has been formally named \"Grip Button\". We retain the name HandTrigger for backwards code"]
    #[doc = " compatibility."]
    #[doc = " User-facing documentation should refer to it as the Grip Button or simply Grip."]
    pub IndexTriggerRaw: [f32; 2usize],
    #[doc = " Left and right hand trigger values (ovrHand_Left and ovrHand_Right), in the range 0.0 to 1.0f."]
    #[doc = " No deadzone or filter"]
    #[doc = " This has been formally named \"Grip Button\". We retain the name HandTrigger for backwards code"]
    #[doc = " compatibility."]
    #[doc = " User-facing documentation should refer to it as the Grip Button or simply Grip."]
    pub HandTriggerRaw: [f32; 2usize],
    #[doc = " Horizontal and vertical thumbstick axis values (ovrHand_Left and ovrHand_Right), in the range"]
    #[doc = " -1.0f to 1.0f"]
    #[doc = " No deadzone or filter"]
    pub ThumbstickRaw: [ovrVector2f; 2usize],
}
#[test]
fn bindgen_test_layout_ovrInputState_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputState_>(),
        120usize,
        concat!("Size of: ", stringify!(ovrInputState_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputState_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputState_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputState_>())).TimeInSeconds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputState_),
            "::",
            stringify!(TimeInSeconds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputState_>())).Buttons as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputState_),
            "::",
            stringify!(Buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputState_>())).Touches as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputState_),
            "::",
            stringify!(Touches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputState_>())).IndexTrigger as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputState_),
            "::",
            stringify!(IndexTrigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputState_>())).HandTrigger as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputState_),
            "::",
            stringify!(HandTrigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputState_>())).Thumbstick as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputState_),
            "::",
            stringify!(Thumbstick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputState_>())).ControllerType as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputState_),
            "::",
            stringify!(ControllerType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputState_>())).IndexTriggerNoDeadzone as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputState_),
            "::",
            stringify!(IndexTriggerNoDeadzone)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputState_>())).HandTriggerNoDeadzone as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputState_),
            "::",
            stringify!(HandTriggerNoDeadzone)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputState_>())).ThumbstickNoDeadzone as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputState_),
            "::",
            stringify!(ThumbstickNoDeadzone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputState_>())).IndexTriggerRaw as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputState_),
            "::",
            stringify!(IndexTriggerRaw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputState_>())).HandTriggerRaw as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputState_),
            "::",
            stringify!(HandTriggerRaw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputState_>())).ThumbstickRaw as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputState_),
            "::",
            stringify!(ThumbstickRaw)
        )
    );
}
pub type ovrInputState = ovrInputState_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrCameraIntrinsics_ {
    #[doc = " Time in seconds from last change to the parameters"]
    pub LastChangedTime: f64,
    #[doc = " Angles of all 4 sides of viewport"]
    pub FOVPort: ovrFovPort,
    #[doc = " Near plane of the virtual camera used to match the external camera"]
    pub VirtualNearPlaneDistanceMeters: f32,
    #[doc = " Far plane of the virtual camera used to match the external camera"]
    pub VirtualFarPlaneDistanceMeters: f32,
    #[doc = " Height in pixels of image sensor"]
    pub ImageSensorPixelResolution: ovrSizei,
    #[doc = " The lens distortion matrix of camera"]
    pub LensDistortionMatrix: ovrMatrix4f,
    #[doc = " How often, in seconds, the exposure is taken"]
    pub ExposurePeriodSeconds: f64,
    #[doc = " length of the exposure time"]
    pub ExposureDurationSeconds: f64,
}
#[test]
fn bindgen_test_layout_ovrCameraIntrinsics_() {
    assert_eq!(
        ::std::mem::size_of::<ovrCameraIntrinsics_>(),
        120usize,
        concat!("Size of: ", stringify!(ovrCameraIntrinsics_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrCameraIntrinsics_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrCameraIntrinsics_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraIntrinsics_>())).LastChangedTime as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraIntrinsics_),
            "::",
            stringify!(LastChangedTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrCameraIntrinsics_>())).FOVPort as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraIntrinsics_),
            "::",
            stringify!(FOVPort)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraIntrinsics_>())).VirtualNearPlaneDistanceMeters
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraIntrinsics_),
            "::",
            stringify!(VirtualNearPlaneDistanceMeters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraIntrinsics_>())).VirtualFarPlaneDistanceMeters
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraIntrinsics_),
            "::",
            stringify!(VirtualFarPlaneDistanceMeters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraIntrinsics_>())).ImageSensorPixelResolution as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraIntrinsics_),
            "::",
            stringify!(ImageSensorPixelResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraIntrinsics_>())).LensDistortionMatrix as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraIntrinsics_),
            "::",
            stringify!(LensDistortionMatrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraIntrinsics_>())).ExposurePeriodSeconds as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraIntrinsics_),
            "::",
            stringify!(ExposurePeriodSeconds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraIntrinsics_>())).ExposureDurationSeconds as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraIntrinsics_),
            "::",
            stringify!(ExposureDurationSeconds)
        )
    );
}
pub type ovrCameraIntrinsics = ovrCameraIntrinsics_;
#[doc = " Initial state of camera"]
pub const ovrCameraStatusFlags__ovrCameraStatus_None: ovrCameraStatusFlags_ = 0;
#[doc = " Bit set when the camera is connected to the system"]
pub const ovrCameraStatusFlags__ovrCameraStatus_Connected: ovrCameraStatusFlags_ = 1;
#[doc = " Bit set when the camera is undergoing calibration"]
pub const ovrCameraStatusFlags__ovrCameraStatus_Calibrating: ovrCameraStatusFlags_ = 2;
#[doc = " Bit set when the camera has tried & failed calibration"]
pub const ovrCameraStatusFlags__ovrCameraStatus_CalibrationFailed: ovrCameraStatusFlags_ = 4;
#[doc = " Bit set when the camera has tried & passed calibration"]
pub const ovrCameraStatusFlags__ovrCameraStatus_Calibrated: ovrCameraStatusFlags_ = 8;
#[doc = " Bit set when the camera is capturing"]
pub const ovrCameraStatusFlags__ovrCameraStatus_Capturing: ovrCameraStatusFlags_ = 16;
#[doc = "< \\internal Force type int32_t."]
pub const ovrCameraStatusFlags__ovrCameraStatus_EnumSize: ovrCameraStatusFlags_ = 2147483647;
pub type ovrCameraStatusFlags_ = i32;
pub use self::ovrCameraStatusFlags_ as ovrCameraStatusFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrCameraExtrinsics_ {
    #[doc = " Time in seconds from last change to the parameters."]
    #[doc = " For instance, if the pose changes, or a camera exposure happens, this struct will be updated."]
    pub LastChangedTimeSeconds: f64,
    #[doc = " Current Status of the camera, a mix of bits from ovrCameraStatusFlags"]
    pub CameraStatusFlags: ::std::os::raw::c_uint,
    #[doc = " Which Tracked device, if any, is the camera rigidly attached to"]
    #[doc = " If set to ovrTrackedDevice_None, then the camera is not attached to a tracked object."]
    #[doc = " If the external camera moves while unattached (i.e. set to ovrTrackedDevice_None), its Pose"]
    #[doc = " won't be updated"]
    pub AttachedToDevice: ovrTrackedDeviceType,
    #[doc = " The relative Pose of the External Camera."]
    #[doc = " If AttachedToDevice is ovrTrackedDevice_None, then this is a absolute pose in tracking space"]
    pub RelativePose: ovrPosef,
    #[doc = " The time, in seconds, when the last successful exposure was taken"]
    pub LastExposureTimeSeconds: f64,
    #[doc = " Estimated exposure latency to get from the exposure time to the system"]
    pub ExposureLatencySeconds: f64,
    #[doc = " Additional latency to get from the exposure time of the real camera to match the render time"]
    #[doc = " of the virtual camera"]
    pub AdditionalLatencySeconds: f64,
}
#[test]
fn bindgen_test_layout_ovrCameraExtrinsics_() {
    assert_eq!(
        ::std::mem::size_of::<ovrCameraExtrinsics_>(),
        72usize,
        concat!("Size of: ", stringify!(ovrCameraExtrinsics_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrCameraExtrinsics_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrCameraExtrinsics_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraExtrinsics_>())).LastChangedTimeSeconds as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraExtrinsics_),
            "::",
            stringify!(LastChangedTimeSeconds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraExtrinsics_>())).CameraStatusFlags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraExtrinsics_),
            "::",
            stringify!(CameraStatusFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraExtrinsics_>())).AttachedToDevice as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraExtrinsics_),
            "::",
            stringify!(AttachedToDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraExtrinsics_>())).RelativePose as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraExtrinsics_),
            "::",
            stringify!(RelativePose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraExtrinsics_>())).LastExposureTimeSeconds as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraExtrinsics_),
            "::",
            stringify!(LastExposureTimeSeconds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraExtrinsics_>())).ExposureLatencySeconds as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraExtrinsics_),
            "::",
            stringify!(ExposureLatencySeconds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrCameraExtrinsics_>())).AdditionalLatencySeconds as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrCameraExtrinsics_),
            "::",
            stringify!(AdditionalLatencySeconds)
        )
    );
}
pub type ovrCameraExtrinsics = ovrCameraExtrinsics_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrExternalCamera_ {
    pub Name: [::std::os::raw::c_char; 32usize],
    pub Intrinsics: ovrCameraIntrinsics,
    pub Extrinsics: ovrCameraExtrinsics,
}
#[test]
fn bindgen_test_layout_ovrExternalCamera_() {
    assert_eq!(
        ::std::mem::size_of::<ovrExternalCamera_>(),
        224usize,
        concat!("Size of: ", stringify!(ovrExternalCamera_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrExternalCamera_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrExternalCamera_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrExternalCamera_>())).Name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrExternalCamera_),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrExternalCamera_>())).Intrinsics as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrExternalCamera_),
            "::",
            stringify!(Intrinsics)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrExternalCamera_>())).Extrinsics as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrExternalCamera_),
            "::",
            stringify!(Extrinsics)
        )
    );
}
pub type ovrExternalCamera = ovrExternalCamera_;
#[doc = " When a debug library is requested, a slower debugging version of the library will"]
#[doc = " run which can be used to help solve problems in the library and debug application code."]
pub const ovrInitFlags__ovrInit_Debug: ovrInitFlags_ = 1;
#[doc = " When a version is requested, the LibOVR runtime respects the RequestedMinorVersion"]
#[doc = " field and verifies that the RequestedMinorVersion is supported. Normally when you"]
#[doc = " specify this flag you simply use OVR_MINOR_VERSION for ovrInitParams::RequestedMinorVersion,"]
#[doc = " though you could use a lower version than OVR_MINOR_VERSION to specify previous"]
#[doc = " version behavior."]
pub const ovrInitFlags__ovrInit_RequestVersion: ovrInitFlags_ = 4;
#[doc = " This client will not be visible in the HMD."]
#[doc = " Typically set by diagnostic or debugging utilities."]
pub const ovrInitFlags__ovrInit_Invisible: ovrInitFlags_ = 16;
#[doc = " This client will alternate between VR and 2D rendering."]
#[doc = " Typically set by game engine editors and VR-enabled web browsers."]
pub const ovrInitFlags__ovrInit_MixedRendering: ovrInitFlags_ = 32;
#[doc = " This client is aware of ovrSessionStatus focus states (e.g. ovrSessionStatus::HasInputFocus),"]
#[doc = " and responds to them appropriately (e.g. pauses and stops drawing hands when lacking focus)."]
pub const ovrInitFlags__ovrInit_FocusAware: ovrInitFlags_ = 64;
#[doc = " These bits are writable by user code."]
pub const ovrInitFlags__ovrinit_WritableBits: ovrInitFlags_ = 16777215;
#[doc = "< \\internal Force type int32_t."]
pub const ovrInitFlags__ovrInit_EnumSize: ovrInitFlags_ = 2147483647;
#[doc = " Initialization flags."]
#[doc = ""]
#[doc = " \\see ovrInitParams, ovr_Initialize"]
#[doc = ""]
pub type ovrInitFlags_ = i32;
pub use self::ovrInitFlags_ as ovrInitFlags;
#[doc = "< Debug-level log event."]
pub const ovrLogLevel__ovrLogLevel_Debug: ovrLogLevel_ = 0;
#[doc = "< Info-level log event."]
pub const ovrLogLevel__ovrLogLevel_Info: ovrLogLevel_ = 1;
#[doc = "< Error-level log event."]
pub const ovrLogLevel__ovrLogLevel_Error: ovrLogLevel_ = 2;
#[doc = "< \\internal Force type int32_t."]
pub const ovrLogLevel__ovrLogLevel_EnumSize: ovrLogLevel_ = 2147483647;
#[doc = " Logging levels"]
#[doc = ""]
#[doc = " \\see ovrInitParams, ovrLogCallback"]
#[doc = ""]
pub type ovrLogLevel_ = i32;
pub use self::ovrLogLevel_ as ovrLogLevel;
#[doc = " Signature of the logging callback function pointer type."]
#[doc = ""]
#[doc = " \\param[in] userData is an arbitrary value specified by the user of ovrInitParams."]
#[doc = " \\param[in] level is one of the ovrLogLevel constants."]
#[doc = " \\param[in] message is a UTF8-encoded null-terminated string."]
#[doc = " \\see ovrInitParams, ovrLogLevel, ovr_Initialize"]
#[doc = ""]
pub type ovrLogCallback = ::std::option::Option<
    unsafe extern "C" fn(
        userData: usize,
        level: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " Parameters for ovr_Initialize."]
#[doc = ""]
#[doc = " \\see ovr_Initialize"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInitParams_ {
    #[doc = " Flags from ovrInitFlags to override default behavior."]
    #[doc = " Use 0 for the defaults."]
    pub Flags: u32,
    #[doc = " Requests a specific minor version of the LibOVR runtime."]
    #[doc = " Flags must include ovrInit_RequestVersion or this will be ignored and OVR_MINOR_VERSION"]
    #[doc = " will be used. If you are directly calling the LibOVRRT version of ovr_Initialize"]
    #[doc = " in the LibOVRRT DLL then this must be valid and include ovrInit_RequestVersion."]
    pub RequestedMinorVersion: u32,
    #[doc = " User-supplied log callback function, which may be called at any time"]
    #[doc = " asynchronously from multiple threads until ovr_Shutdown completes."]
    #[doc = " Use NULL to specify no log callback."]
    pub LogCallback: ovrLogCallback,
    #[doc = " User-supplied data which is passed as-is to LogCallback. Typically this"]
    #[doc = " is used to store an application-specific pointer which is read in the"]
    #[doc = " callback function."]
    pub UserData: usize,
    #[doc = " Relative number of milliseconds to wait for a connection to the server"]
    #[doc = " before failing. Use 0 for the default timeout."]
    pub ConnectionTimeoutMS: u32,
    pub pad0: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_ovrInitParams_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInitParams_>(),
        32usize,
        concat!("Size of: ", stringify!(ovrInitParams_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInitParams_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInitParams_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParams_>())).Flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParams_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInitParams_>())).RequestedMinorVersion as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParams_),
            "::",
            stringify!(RequestedMinorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParams_>())).LogCallback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParams_),
            "::",
            stringify!(LogCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParams_>())).UserData as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParams_),
            "::",
            stringify!(UserData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInitParams_>())).ConnectionTimeoutMS as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParams_),
            "::",
            stringify!(ConnectionTimeoutMS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParams_>())).pad0 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParams_),
            "::",
            stringify!(pad0)
        )
    );
}
pub type ovrInitParams = ovrInitParams_;
extern "C" {
    #[doc = " Initializes LibOVR"]
    #[doc = ""]
    #[doc = " Initialize LibOVR for application usage. This includes finding and loading the LibOVRRT"]
    #[doc = " shared library. No LibOVR API functions, other than ovr_GetLastErrorInfo and ovr_Detect, can"]
    #[doc = " be called unless ovr_Initialize succeeds. A successful call to ovr_Initialize must be eventually"]
    #[doc = " followed by a call to ovr_Shutdown. ovr_Initialize calls are idempotent."]
    #[doc = " Calling ovr_Initialize twice does not require two matching calls to ovr_Shutdown."]
    #[doc = " If already initialized, the return value is ovr_Success."]
    #[doc = ""]
    #[doc = " LibOVRRT shared library search order:"]
    #[doc = "      -# Current working directory (often the same as the application directory)."]
    #[doc = "      -# Module directory (usually the same as the application directory,"]
    #[doc = "         but not if the module is a separate shared library)."]
    #[doc = "      -# Application directory"]
    #[doc = "      -# Standard OS shared library search location(s) (OS-specific)."]
    #[doc = ""]
    #[doc = " \\param params Specifies custom initialization options. May be NULL to indicate default options"]
    #[doc = "        when using the CAPI shim. If you are directly calling the LibOVRRT version of"]
    #[doc = "        ovr_Initialize in the LibOVRRT DLL then this must be valid and"]
    #[doc = "        include ovrInit_RequestVersion."]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of failure, use"]
    #[doc = "         ovr_GetLastErrorInfo to get more information. Example failed results include:"]
    #[doc = "     - ovrError_Initialize: Generic initialization error."]
    #[doc = "     - ovrError_LibLoad: Couldn't load LibOVRRT."]
    #[doc = "     - ovrError_LibVersion: LibOVRRT version incompatibility."]
    #[doc = "     - ovrError_ServiceConnection: Couldn't connect to the OVR Service."]
    #[doc = "     - ovrError_ServiceVersion: OVR Service version incompatibility."]
    #[doc = "     - ovrError_IncompatibleOS: The operating system version is incompatible."]
    #[doc = "     - ovrError_DisplayInit: Unable to initialize the HMD display."]
    #[doc = "     - ovrError_ServerStart:  Unable to start the server. Is it already running?"]
    #[doc = "     - ovrError_Reinitialization: Attempted to re-initialize with a different version."]
    #[doc = ""]
    #[doc = " <b>Example code</b>"]
    #[doc = "     \\code{.cpp}"]
    #[doc = "         ovrInitParams initParams = { ovrInit_RequestVersion, OVR_MINOR_VERSION, NULL, 0, 0 };"]
    #[doc = "         ovrResult result = ovr_Initialize(&initParams);"]
    #[doc = "         if(OVR_FAILURE(result)) {"]
    #[doc = "             ovrErrorInfo errorInfo;"]
    #[doc = "             ovr_GetLastErrorInfo(&errorInfo);"]
    #[doc = "             DebugLog(\"ovr_Initialize failed: %s\", errorInfo.ErrorString);"]
    #[doc = "             return false;"]
    #[doc = "         }"]
    #[doc = "         [...]"]
    #[doc = "     \\endcode"]
    #[doc = ""]
    #[doc = " \\see ovr_Shutdown"]
    #[doc = ""]
    pub fn ovr_Initialize(params: *const ovrInitParams) -> ovrResult;
}
extern "C" {
    #[doc = " Shuts down LibOVR"]
    #[doc = ""]
    #[doc = " A successful call to ovr_Initialize must be eventually matched by a call to ovr_Shutdown."]
    #[doc = " After calling ovr_Shutdown, no LibOVR functions can be called except ovr_GetLastErrorInfo"]
    #[doc = " or another ovr_Initialize. ovr_Shutdown invalidates all pointers, references, and created"]
    #[doc = " objects"]
    #[doc = " previously returned by LibOVR functions. The LibOVRRT shared library can be unloaded by"]
    #[doc = " ovr_Shutdown."]
    #[doc = ""]
    #[doc = " \\see ovr_Initialize"]
    #[doc = ""]
    pub fn ovr_Shutdown();
}
extern "C" {
    #[doc = " Returns information about the most recent failed return value by the"]
    #[doc = " current thread for this library."]
    #[doc = ""]
    #[doc = " This function itself can never generate an error."]
    #[doc = " The last error is never cleared by LibOVR, but will be overwritten by new errors."]
    #[doc = " Do not use this call to determine if there was an error in the last API"]
    #[doc = " call as successful API calls don't clear the last ovrErrorInfo."]
    #[doc = " To avoid any inconsistency, ovr_GetLastErrorInfo should be called immediately"]
    #[doc = " after an API function that returned a failed ovrResult, with no other API"]
    #[doc = " functions called in the interim."]
    #[doc = ""]
    #[doc = " \\param[out] errorInfo The last ovrErrorInfo for the current thread."]
    #[doc = ""]
    #[doc = " \\see ovrErrorInfo"]
    #[doc = ""]
    pub fn ovr_GetLastErrorInfo(errorInfo: *mut ovrErrorInfo);
}
extern "C" {
    #[doc = " Returns the version string representing the LibOVRRT version."]
    #[doc = ""]
    #[doc = " The returned string pointer is valid until the next call to ovr_Shutdown."]
    #[doc = ""]
    #[doc = " Note that the returned version string doesn't necessarily match the current"]
    #[doc = " OVR_MAJOR_VERSION, etc., as the returned string refers to the LibOVRRT shared"]
    #[doc = " library version and not the locally compiled interface version."]
    #[doc = ""]
    #[doc = " The format of this string is subject to change in future versions and its contents"]
    #[doc = " should not be interpreted."]
    #[doc = ""]
    #[doc = " \\return Returns a UTF8-encoded null-terminated version string."]
    #[doc = ""]
    pub fn ovr_GetVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Writes a message string to the LibOVR tracing mechanism (if enabled)."]
    #[doc = ""]
    #[doc = " This message will be passed back to the application via the ovrLogCallback if"]
    #[doc = " it was registered."]
    #[doc = ""]
    #[doc = " \\param[in] level One of the ovrLogLevel constants."]
    #[doc = " \\param[in] message A UTF8-encoded null-terminated string."]
    #[doc = " \\return returns the strlen of the message or a negative value if the message is too large."]
    #[doc = ""]
    #[doc = " \\see ovrLogLevel, ovrLogCallback"]
    #[doc = ""]
    pub fn ovr_TraceMessage(
        level: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identify client application info."]
    #[doc = ""]
    #[doc = " The string is one or more newline-delimited lines of optional info"]
    #[doc = " indicating engine name, engine version, engine plugin name, engine plugin"]
    #[doc = " version, engine editor. The order of the lines is not relevant. Individual"]
    #[doc = " lines are optional. A newline is not necessary at the end of the last line."]
    #[doc = " Call after ovr_Initialize and before the first call to ovr_Create."]
    #[doc = " Each value is limited to 20 characters. Key names such as 'EngineName:'"]
    #[doc = " 'EngineVersion:' do not count towards this limit."]
    #[doc = ""]
    #[doc = " \\param[in] identity Specifies one or more newline-delimited lines of optional info:"]
    #[doc = "             EngineName: %s\\n"]
    #[doc = "             EngineVersion: %s\\n"]
    #[doc = "             EnginePluginName: %s\\n"]
    #[doc = "             EnginePluginVersion: %s\\n"]
    #[doc = "             EngineEditor: <boolean> ('true' or 'false')\\n"]
    #[doc = ""]
    #[doc = " <b>Example code</b>"]
    #[doc = "     \\code{.cpp}"]
    #[doc = "     ovr_IdentifyClient(\"EngineName: Unity\\n\""]
    #[doc = "                        \"EngineVersion: 5.3.3\\n\""]
    #[doc = "                        \"EnginePluginName: OVRPlugin\\n\""]
    #[doc = "                        \"EnginePluginVersion: 1.2.0\\n\""]
    #[doc = "                        \"EngineEditor: true\");"]
    #[doc = "     \\endcode"]
    #[doc = ""]
    pub fn ovr_IdentifyClient(identity: *const ::std::os::raw::c_char) -> ovrResult;
}
extern "C" {
    #[doc = " Returns information about the current HMD."]
    #[doc = ""]
    #[doc = " ovr_Initialize must be called prior to calling this function,"]
    #[doc = " otherwise ovrHmdDesc::Type will be set to ovrHmd_None without"]
    #[doc = " checking for the HMD presence."]
    #[doc = ""]
    #[doc = " For newer headsets being used on a game built against an old SDK version,"]
    #[doc = " we may return the ovrHmdType as ovrHmd_CV1 for backwards compatibility."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create() or NULL."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrHmdDesc. If invoked with NULL session argument, ovrHmdDesc::Type"]
    #[doc = "         set to ovrHmd_None indicates that the HMD is not connected."]
    #[doc = ""]
    pub fn ovr_GetHmdDesc(session: ovrSession) -> ovrHmdDesc;
}
extern "C" {
    #[doc = " Returns the number of attached trackers."]
    #[doc = ""]
    #[doc = " The number of trackers may change at any time, so this function should be called before use"]
    #[doc = " as opposed to once on startup."]
    #[doc = ""]
    #[doc = " For newer headsets being used on a game built against an old SDK version,"]
    #[doc = " we may simulate three CV1 trackers to maintain backwards compatibility."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = ""]
    #[doc = " \\return Returns unsigned int count."]
    #[doc = ""]
    pub fn ovr_GetTrackerCount(session: ovrSession) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns a given attached tracker description."]
    #[doc = ""]
    #[doc = " ovr_Initialize must have first been called in order for this to succeed, otherwise the returned"]
    #[doc = " trackerDescArray will be zero-initialized. The data returned by this function can change at"]
    #[doc = " runtime."]
    #[doc = ""]
    #[doc = " For newer headsets being used on a game built against an old SDK version,"]
    #[doc = " we may simulate three CV1 trackers to maintain backwards compatibility."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = ""]
    #[doc = " \\param[in] trackerDescIndex Specifies a tracker index. The valid indexes are in the"]
    #[doc = "            range of 0 to the tracker count returned by ovr_GetTrackerCount."]
    #[doc = ""]
    #[doc = " \\return Returns ovrTrackerDesc. An empty ovrTrackerDesc will be returned if"]
    #[doc = "           trackerDescIndex is out of range."]
    #[doc = ""]
    #[doc = " \\see ovrTrackerDesc, ovr_GetTrackerCount"]
    #[doc = ""]
    pub fn ovr_GetTrackerDesc(
        session: ovrSession,
        trackerDescIndex: ::std::os::raw::c_uint,
    ) -> ovrTrackerDesc;
}
extern "C" {
    #[doc = " Creates a handle to a VR session."]
    #[doc = ""]
    #[doc = " Upon success the returned ovrSession must be eventually freed with ovr_Destroy when it is no"]
    #[doc = " longer needed."]
    #[doc = " A second call to ovr_Create will result in an error return value if the previous session has not"]
    #[doc = " been destroyed."]
    #[doc = ""]
    #[doc = " \\param[out] pSession Provides a pointer to an ovrSession which will be written to upon success."]
    #[doc = " \\param[out] pLuid Provides a system specific graphics adapter identifier that locates which"]
    #[doc = " graphics adapter has the HMD attached. This must match the adapter used by the application"]
    #[doc = " or no rendering output will be possible. This is important for stability on multi-adapter"]
    #[doc = " systems. An"]
    #[doc = " application that simply chooses the default adapter will not run reliably on multi-adapter"]
    #[doc = " systems."]
    #[doc = " \\return Returns an ovrResult indicating success or failure. Upon failure"]
    #[doc = "         the returned ovrSession will be NULL."]
    #[doc = ""]
    #[doc = " <b>Example code</b>"]
    #[doc = "     \\code{.cpp}"]
    #[doc = "         ovrSession session;"]
    #[doc = "         ovrGraphicsLuid luid;"]
    #[doc = "         ovrResult result = ovr_Create(&session, &luid);"]
    #[doc = "         if(OVR_FAILURE(result))"]
    #[doc = "            ..."]
    #[doc = "     \\endcode"]
    #[doc = ""]
    #[doc = " \\see ovr_Destroy"]
    #[doc = ""]
    pub fn ovr_Create(pSession: *mut ovrSession, pLuid: *mut ovrGraphicsLuid) -> ovrResult;
}
extern "C" {
    #[doc = " Destroys the session."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\see ovr_Create"]
    #[doc = ""]
    pub fn ovr_Destroy(session: ovrSession);
}
#[doc = " Specifies status information for the current session."]
#[doc = ""]
#[doc = " \\see ovr_GetSessionStatus"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrSessionStatus_ {
    #[doc = " True if the process has VR focus and thus is visible in the HMD."]
    pub IsVisible: ovrBool,
    #[doc = " True if an HMD is present."]
    pub HmdPresent: ovrBool,
    #[doc = " True if the HMD is on the user's head."]
    pub HmdMounted: ovrBool,
    #[doc = " True if the session is in a display-lost state. See ovr_SubmitFrame."]
    pub DisplayLost: ovrBool,
    #[doc = " True if the application should initiate shutdown."]
    pub ShouldQuit: ovrBool,
    #[doc = " True if UX has requested re-centering. Must call ovr_ClearShouldRecenterFlag,"]
    #[doc = " ovr_RecenterTrackingOrigin or ovr_SpecifyTrackingOrigin."]
    pub ShouldRecenter: ovrBool,
    #[doc = " True if the application is the foreground application and receives input (e.g. Touch"]
    #[doc = " controller state). If this is false then the application is in the background (but possibly"]
    #[doc = " still visible) should hide any input representations such as hands."]
    pub HasInputFocus: ovrBool,
    #[doc = " True if a system overlay is present, such as a dashboard. In this case the application"]
    #[doc = " (if visible) should pause while still drawing, avoid drawing near-field graphics so they"]
    #[doc = " don't visually fight with the system overlay, and consume fewer CPU and GPU resources."]
    #[doc = " \\deprecated Do not use."]
    pub OverlayPresent: ovrBool,
    #[doc = " True if runtime is requesting that the application provide depth buffers with projection"]
    #[doc = " layers."]
    pub DepthRequested: ovrBool,
}
#[test]
fn bindgen_test_layout_ovrSessionStatus_() {
    assert_eq!(
        ::std::mem::size_of::<ovrSessionStatus_>(),
        9usize,
        concat!("Size of: ", stringify!(ovrSessionStatus_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrSessionStatus_>(),
        1usize,
        concat!("Alignment of ", stringify!(ovrSessionStatus_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSessionStatus_>())).IsVisible as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSessionStatus_),
            "::",
            stringify!(IsVisible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSessionStatus_>())).HmdPresent as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSessionStatus_),
            "::",
            stringify!(HmdPresent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSessionStatus_>())).HmdMounted as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSessionStatus_),
            "::",
            stringify!(HmdMounted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSessionStatus_>())).DisplayLost as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSessionStatus_),
            "::",
            stringify!(DisplayLost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSessionStatus_>())).ShouldQuit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSessionStatus_),
            "::",
            stringify!(ShouldQuit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSessionStatus_>())).ShouldRecenter as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSessionStatus_),
            "::",
            stringify!(ShouldRecenter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSessionStatus_>())).HasInputFocus as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSessionStatus_),
            "::",
            stringify!(HasInputFocus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSessionStatus_>())).OverlayPresent as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSessionStatus_),
            "::",
            stringify!(OverlayPresent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSessionStatus_>())).DepthRequested as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSessionStatus_),
            "::",
            stringify!(DepthRequested)
        )
    );
}
pub type ovrSessionStatus = ovrSessionStatus_;
extern "C" {
    #[doc = " Returns status information for the application."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[out] sessionStatus Provides an ovrSessionStatus that is filled in."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of"]
    #[doc = "         failure, use ovr_GetLastErrorInfo to get more information."]
    #[doc = "         Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: Completed successfully."]
    #[doc = "     - ovrError_ServiceConnection: The service connection was lost and the application"]
    #[doc = "       must destroy the session."]
    #[doc = ""]
    pub fn ovr_GetSessionStatus(
        session: ovrSession,
        sessionStatus: *mut ovrSessionStatus,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Query extension support status."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] extension Extension to query."]
    #[doc = " \\param[out] outExtensionSupported Set to extension support status. ovrTrue if supported."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of"]
    #[doc = "         failure use ovr_GetLastErrorInfo to get more information."]
    #[doc = ""]
    #[doc = " \\see ovrExtensions"]
    #[doc = ""]
    pub fn ovr_IsExtensionSupported(
        session: ovrSession,
        extension: ovrExtensions,
        outExtensionSupported: *mut ovrBool,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Enable extension. Extensions must be enabled after ovr_Create is called."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] extension Extension to enable."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. Extension is only"]
    #[doc = "         enabled if successful. In the case of failure use ovr_GetLastErrorInfo"]
    #[doc = "         to get more information."]
    #[doc = ""]
    #[doc = " \\see ovrExtensions"]
    #[doc = ""]
    pub fn ovr_EnableExtension(session: ovrSession, extension: ovrExtensions) -> ovrResult;
}
extern "C" {
    #[doc = " Sets the tracking origin type"]
    #[doc = ""]
    #[doc = " When the tracking origin is changed, all of the calls that either provide"]
    #[doc = " or accept ovrPosef will use the new tracking origin provided."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] origin Specifies an ovrTrackingOrigin to be used for all ovrPosef"]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of failure, use"]
    #[doc = "         ovr_GetLastErrorInfo to get more information."]
    #[doc = ""]
    #[doc = " \\see ovrTrackingOrigin, ovr_GetTrackingOriginType"]
    pub fn ovr_SetTrackingOriginType(session: ovrSession, origin: ovrTrackingOrigin) -> ovrResult;
}
extern "C" {
    #[doc = " Gets the tracking origin state"]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = ""]
    #[doc = " \\return Returns the ovrTrackingOrigin that was either set by default, or previous set by the"]
    #[doc = " application."]
    #[doc = ""]
    #[doc = " \\see ovrTrackingOrigin, ovr_SetTrackingOriginType"]
    pub fn ovr_GetTrackingOriginType(session: ovrSession) -> ovrTrackingOrigin;
}
extern "C" {
    #[doc = " Re-centers the sensor position and orientation."]
    #[doc = ""]
    #[doc = " This resets the (x,y,z) positional components and the yaw orientation component of the"]
    #[doc = " tracking space for the HMD and controllers using the HMD's current tracking pose."]
    #[doc = " If the caller requires some tweaks on top of the HMD's current tracking pose, consider using"]
    #[doc = " ovr_SpecifyTrackingOrigin instead."]
    #[doc = ""]
    #[doc = " The roll and pitch orientation components are always determined by gravity and cannot"]
    #[doc = " be redefined. All future tracking will report values relative to this new reference position."]
    #[doc = " If you are using ovrTrackerPoses then you will need to call ovr_GetTrackerPose after"]
    #[doc = " this, because the sensor position(s) will change as a result of this."]
    #[doc = ""]
    #[doc = " The headset cannot be facing vertically upward or downward but rather must be roughly"]
    #[doc = " level otherwise this function will fail with ovrError_InvalidHeadsetOrientation."]
    #[doc = ""]
    #[doc = " For more info, see the notes on each ovrTrackingOrigin enumeration to understand how"]
    #[doc = " recenter will vary slightly in its behavior based on the current ovrTrackingOrigin setting."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of failure, use"]
    #[doc = "         ovr_GetLastErrorInfo to get more information. Return values include but aren't limited"]
    #[doc = "         to:"]
    #[doc = "     - ovrSuccess: Completed successfully."]
    #[doc = "     - ovrError_InvalidHeadsetOrientation: The headset was facing an invalid direction when"]
    #[doc = "       attempting recentering, such as facing vertically."]
    #[doc = ""]
    #[doc = " \\see ovrTrackingOrigin, ovr_GetTrackerPose, ovr_SpecifyTrackingOrigin"]
    #[doc = ""]
    pub fn ovr_RecenterTrackingOrigin(session: ovrSession) -> ovrResult;
}
extern "C" {
    #[doc = " Allows manually tweaking the sensor position and orientation."]
    #[doc = ""]
    #[doc = " This function is similar to ovr_RecenterTrackingOrigin in that it modifies the"]
    #[doc = " (x,y,z) positional components and the yaw orientation component of the tracking space for"]
    #[doc = " the HMD and controllers."]
    #[doc = ""]
    #[doc = " While ovr_RecenterTrackingOrigin resets the tracking origin in reference to the HMD's"]
    #[doc = " current pose, ovr_SpecifyTrackingOrigin allows the caller to explicitly specify a transform"]
    #[doc = " for the tracking origin. This transform is expected to be an offset to the most recent"]
    #[doc = " recentered origin, so calling this function repeatedly with the same originPose will keep"]
    #[doc = " nudging the recentered origin in that direction."]
    #[doc = ""]
    #[doc = " There are several use cases for this function. For example, if the application decides to"]
    #[doc = " limit the yaw, or translation of the recentered pose instead of directly using the HMD pose"]
    #[doc = " the application can query the current tracking state via ovr_GetTrackingState, and apply"]
    #[doc = " some limitations to the HMD pose because feeding this pose back into this function."]
    #[doc = " Similarly, this can be used to \"adjust the seating position\" incrementally in apps that"]
    #[doc = " feature seated experiences such as cockpit-based games."]
    #[doc = ""]
    #[doc = " This function can emulate ovr_RecenterTrackingOrigin as such:"]
    #[doc = "     ovrTrackingState ts = ovr_GetTrackingState(session, 0.0, ovrFalse);"]
    #[doc = "     ovr_SpecifyTrackingOrigin(session, ts.HeadPose.ThePose);"]
    #[doc = ""]
    #[doc = " The roll and pitch orientation components are determined by gravity and cannot be redefined."]
    #[doc = " If you are using ovrTrackerPoses then you will need to call ovr_GetTrackerPose after"]
    #[doc = " this, because the sensor position(s) will change as a result of this."]
    #[doc = ""]
    #[doc = " For more info, see the notes on each ovrTrackingOrigin enumeration to understand how"]
    #[doc = " recenter will vary slightly in its behavior based on the current ovrTrackingOrigin setting."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] originPose Specifies a pose that will be used to transform the current tracking"]
    #[doc = " origin."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of failure, use"]
    #[doc = "         ovr_GetLastErrorInfo to get more information. Return values include but aren't limited"]
    #[doc = "         to:"]
    #[doc = "     - ovrSuccess: Completed successfully."]
    #[doc = "     - ovrError_InvalidParameter: The heading direction in originPose was invalid,"]
    #[doc = "         such as facing vertically. This can happen if the caller is directly feeding the pose"]
    #[doc = "         of a position-tracked device such as an HMD or controller into this function."]
    #[doc = ""]
    #[doc = " \\see ovrTrackingOrigin, ovr_GetTrackerPose, ovr_RecenterTrackingOrigin"]
    #[doc = ""]
    pub fn ovr_SpecifyTrackingOrigin(session: ovrSession, originPose: ovrPosef) -> ovrResult;
}
extern "C" {
    #[doc = " Clears the ShouldRecenter status bit in ovrSessionStatus."]
    #[doc = ""]
    #[doc = " Clears the ShouldRecenter status bit in ovrSessionStatus, allowing further recenter requests to"]
    #[doc = " be detected. Since this is automatically done by ovr_RecenterTrackingOrigin and"]
    #[doc = " ovr_SpecifyTrackingOrigin, this function only needs to be called when application is doing"]
    #[doc = " its own re-centering logic."]
    pub fn ovr_ClearShouldRecenterFlag(session: ovrSession);
}
extern "C" {
    #[doc = " Returns tracking state reading based on the specified absolute system time."]
    #[doc = ""]
    #[doc = " Pass an absTime value of 0.0 to request the most recent sensor reading. In this case"]
    #[doc = " both PredictedPose and SamplePose will have the same value."]
    #[doc = ""]
    #[doc = " This may also be used for more refined timing of front buffer rendering logic, and so on."]
    #[doc = " This may be called by multiple threads."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] absTime Specifies the absolute future time to predict the return"]
    #[doc = "            ovrTrackingState value. Use 0 to request the most recent tracking state."]
    #[doc = " \\param[in] latencyMarker Specifies that this call is the point in time where"]
    #[doc = "            the \"App-to-Mid-Photon\" latency timer starts from. If a given ovrLayer"]
    #[doc = "            provides \"SensorSampleTime\", that will override the value stored here."]
    #[doc = " \\return Returns the ovrTrackingState that is predicted for the given absTime."]
    #[doc = ""]
    #[doc = " \\see ovrTrackingState, ovr_GetEyePoses, ovr_GetTimeInSeconds"]
    #[doc = ""]
    pub fn ovr_GetTrackingState(
        session: ovrSession,
        absTime: f64,
        latencyMarker: ovrBool,
    ) -> ovrTrackingState;
}
extern "C" {
    #[doc = " Returns an array of poses, where each pose matches a device type provided by the deviceTypes"]
    #[doc = " array parameter.  If any pose cannot be retrieved, it will return a reason for the missing"]
    #[doc = " pose and the device pose will be zeroed out with a pose quaternion [x=0, y=0, z=0, w=1]."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] deviceTypes Array of device types to query for their poses."]
    #[doc = " \\param[in] deviceCount Number of queried poses. This number must match the length of the"]
    #[doc = " outDevicePoses and deviceTypes array."]
    #[doc = " \\param[in] absTime Specifies the absolute future time to predict the return"]
    #[doc = "             ovrTrackingState value. Use 0 to request the most recent tracking state."]
    #[doc = " \\param[out] outDevicePoses Array of poses, one for each device type in deviceTypes arrays."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and"]
    #[doc = "         true upon success."]
    #[doc = ""]
    pub fn ovr_GetDevicePoses(
        session: ovrSession,
        deviceTypes: *mut ovrTrackedDeviceType,
        deviceCount: ::std::os::raw::c_int,
        absTime: f64,
        outDevicePoses: *mut ovrPoseStatef,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Returns the ovrTrackerPose for the given attached tracker."]
    #[doc = ""]
    #[doc = " For newer headsets being used on a game built against an old SDK version,"]
    #[doc = " we may simulate three CV1 trackers to maintain backwards compatibility."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] trackerPoseIndex Index of the tracker being requested."]
    #[doc = ""]
    #[doc = " \\return Returns the requested ovrTrackerPose. An empty ovrTrackerPose will be returned if"]
    #[doc = " trackerPoseIndex is out of range."]
    #[doc = ""]
    #[doc = " \\see ovr_GetTrackerCount"]
    #[doc = ""]
    pub fn ovr_GetTrackerPose(
        session: ovrSession,
        trackerPoseIndex: ::std::os::raw::c_uint,
    ) -> ovrTrackerPose;
}
extern "C" {
    #[doc = " Returns the most recent input state for controllers, without positional tracking info."]
    #[doc = ""]
    #[doc = " \\param[out] inputState Input state that will be filled in."]
    #[doc = " \\param[in] controllerType Specifies which controller the input will be returned for."]
    #[doc = " \\return Returns ovrSuccess if the new state was successfully obtained."]
    #[doc = ""]
    #[doc = " \\see ovrControllerType"]
    #[doc = ""]
    pub fn ovr_GetInputState(
        session: ovrSession,
        controllerType: ovrControllerType,
        inputState: *mut ovrInputState,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Returns controller types connected to the system OR'ed together."]
    #[doc = ""]
    #[doc = " \\return A bitmask of ovrControllerTypes connected to the system."]
    #[doc = ""]
    #[doc = " \\see ovrControllerType"]
    #[doc = ""]
    pub fn ovr_GetConnectedControllerTypes(session: ovrSession) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Gets information about Haptics engine for the specified Touch controller."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] controllerType The controller to retrieve the information from."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrTouchHapticsDesc."]
    #[doc = ""]
    pub fn ovr_GetTouchHapticsDesc(
        session: ovrSession,
        controllerType: ovrControllerType,
    ) -> ovrTouchHapticsDesc;
}
extern "C" {
    #[doc = " Sets constant vibration (with specified frequency and amplitude) to a controller."]
    #[doc = " Note: ovr_SetControllerVibration cannot be used interchangeably with"]
    #[doc = " ovr_SubmitControllerVibration."]
    #[doc = ""]
    #[doc = " This method should be called periodically, vibration lasts for a maximum of 2.5 seconds."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] controllerType The controller to set the vibration to."]
    #[doc = " \\param[in] frequency Vibration frequency. Supported values are: 0.0 (disabled), 0.5 and 1.0. Non"]
    #[doc = " valid values will be clamped."]
    #[doc = " \\param[in] amplitude Vibration amplitude in the [0.0, 1.0] range."]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success. Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: The call succeeded and a result was returned."]
    #[doc = "     - ovrSuccess_DeviceUnavailable: The call succeeded but the device referred to by"]
    #[doc = "     controllerType is not available."]
    #[doc = ""]
    pub fn ovr_SetControllerVibration(
        session: ovrSession,
        controllerType: ovrControllerType,
        frequency: f32,
        amplitude: f32,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Submits a Haptics buffer (used for vibration) to Touch (only) controllers."]
    #[doc = " Note: ovr_SubmitControllerVibration cannot be used interchangeably with"]
    #[doc = " ovr_SetControllerVibration."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] controllerType Controller where the Haptics buffer will be played."]
    #[doc = " \\param[in] buffer Haptics buffer containing amplitude samples to be played."]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success. Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: The call succeeded and a result was returned."]
    #[doc = "     - ovrSuccess_DeviceUnavailable: The call succeeded but the device referred to by"]
    #[doc = "     controllerType is not available."]
    #[doc = ""]
    #[doc = " \\see ovrHapticsBuffer"]
    #[doc = ""]
    pub fn ovr_SubmitControllerVibration(
        session: ovrSession,
        controllerType: ovrControllerType,
        buffer: *const ovrHapticsBuffer,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Gets the Haptics engine playback state of a specific Touch controller."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] controllerType Controller where the Haptics buffer wil be played."]
    #[doc = " \\param[in] outState State of the haptics engine."]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success. Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: The call succeeded and a result was returned."]
    #[doc = "     - ovrSuccess_DeviceUnavailable: The call succeeded but the device referred to by"]
    #[doc = "     controllerType is not available."]
    #[doc = ""]
    #[doc = " \\see ovrHapticsPlaybackState"]
    #[doc = ""]
    pub fn ovr_GetControllerVibrationState(
        session: ovrSession,
        controllerType: ovrControllerType,
        outState: *mut ovrHapticsPlaybackState,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Tests collision/proximity of position tracked devices (e.g. HMD and/or Touch) against the"]
    #[doc = " Boundary System."]
    #[doc = " Note: this method is similar to ovr_BoundaryTestPoint but can be more precise as it may take"]
    #[doc = " into account device acceleration/momentum."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] deviceBitmask Bitmask of one or more tracked devices to test."]
    #[doc = " \\param[in] boundaryType Must be either ovrBoundary_Outer or ovrBoundary_PlayArea."]
    #[doc = " \\param[out] outTestResult Result of collision/proximity test, contains information such as"]
    #[doc = " distance and closest point."]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success. Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: The call succeeded and a result was returned."]
    #[doc = "     - ovrSuccess_BoundaryInvalid: The call succeeded but the result is not a valid boundary due"]
    #[doc = "     to not being set up."]
    #[doc = "     - ovrSuccess_DeviceUnavailable: The call succeeded but the device referred to by"]
    #[doc = "     deviceBitmask is not available."]
    #[doc = ""]
    #[doc = " \\see ovrBoundaryTestResult"]
    #[doc = ""]
    pub fn ovr_TestBoundary(
        session: ovrSession,
        deviceBitmask: ovrTrackedDeviceType,
        boundaryType: ovrBoundaryType,
        outTestResult: *mut ovrBoundaryTestResult,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Tests collision/proximity of a 3D point against the Boundary System."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] point 3D point to test."]
    #[doc = " \\param[in] singleBoundaryType Must be either ovrBoundary_Outer or ovrBoundary_PlayArea to test"]
    #[doc = " against"]
    #[doc = " \\param[out] outTestResult Result of collision/proximity test, contains information such as"]
    #[doc = " distance and closest point."]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success. Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: The call succeeded and a result was returned."]
    #[doc = "     - ovrSuccess_BoundaryInvalid: The call succeeded but the result is not a valid boundary due"]
    #[doc = "     to not being set up."]
    #[doc = ""]
    #[doc = " \\see ovrBoundaryTestResult"]
    #[doc = ""]
    pub fn ovr_TestBoundaryPoint(
        session: ovrSession,
        point: *const ovrVector3f,
        singleBoundaryType: ovrBoundaryType,
        outTestResult: *mut ovrBoundaryTestResult,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Compatibility stub."]
    #[doc = ""]
    #[doc = " \\deprecated Previously set the look and feel of the Boundary System - this functionality has"]
    #[doc = " been removed."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] lookAndFeel Look and feel parameters."]
    #[doc = " \\return Returns ovrSuccess upon success."]
    #[doc = " \\see ovrBoundaryLookAndFeel"]
    #[doc = ""]
    pub fn ovr_SetBoundaryLookAndFeel(
        session: ovrSession,
        lookAndFeel: *const ovrBoundaryLookAndFeel,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Resets the look and feel of the Boundary System to its default state."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\return Returns ovrSuccess upon success."]
    #[doc = " \\see ovrBoundaryLookAndFeel"]
    #[doc = ""]
    pub fn ovr_ResetBoundaryLookAndFeel(session: ovrSession) -> ovrResult;
}
extern "C" {
    #[doc = " Gets the geometry of the Boundary System's \"play area\" or \"outer boundary\" as 3D floor points."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] boundaryType Must be either ovrBoundary_Outer or ovrBoundary_PlayArea."]
    #[doc = " \\param[out] outFloorPoints Array of 3D points (in clockwise order) defining the boundary at"]
    #[doc = " floor height (can be NULL to retrieve only the number of points)."]
    #[doc = " \\param[out] outFloorPointsCount Number of 3D points returned in the array."]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success. Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: The call succeeded and a result was returned."]
    #[doc = "     - ovrSuccess_BoundaryInvalid: The call succeeded but the result is not a valid boundary due"]
    #[doc = "     to not being set up."]
    #[doc = ""]
    pub fn ovr_GetBoundaryGeometry(
        session: ovrSession,
        boundaryType: ovrBoundaryType,
        outFloorPoints: *mut ovrVector3f,
        outFloorPointsCount: *mut ::std::os::raw::c_int,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Gets the dimension of the Boundary System's \"play area\" or \"outer boundary\"."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] boundaryType Must be either ovrBoundary_Outer or ovrBoundary_PlayArea."]
    #[doc = " \\param[out] outDimensions Dimensions of the axis aligned bounding box that encloses the area in"]
    #[doc = " meters (width, height and length)."]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success. Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: The call succeeded and a result was returned."]
    #[doc = "     - ovrSuccess_BoundaryInvalid: The call succeeded but the result is not a valid boundary due"]
    #[doc = "     to not being set up."]
    #[doc = ""]
    pub fn ovr_GetBoundaryDimensions(
        session: ovrSession,
        boundaryType: ovrBoundaryType,
        outDimensions: *mut ovrVector3f,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Returns if the boundary is currently visible."]
    #[doc = " Note: visibility is false if the user has turned off boundaries, otherwise, it's true if"]
    #[doc = " the app has requested boundaries to be visible or if any tracked device is currently"]
    #[doc = " triggering it. This may not exactly match rendering due to fade-in and fade-out effects."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[out] outIsVisible ovrTrue, if the boundary is visible."]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success. Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: Result was successful and a result was returned."]
    #[doc = "     - ovrSuccess_BoundaryInvalid: The call succeeded but the result is not a valid boundary due"]
    #[doc = "     to not being set up."]
    #[doc = ""]
    pub fn ovr_GetBoundaryVisible(session: ovrSession, outIsVisible: *mut ovrBool) -> ovrResult;
}
extern "C" {
    #[doc = " Requests boundary to be visible."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] visible forces the outer boundary to be visible. An application can't force it"]
    #[doc = "            to be invisible, but can cancel its request by passing false."]
    #[doc = " \\return Returns ovrSuccess upon success."]
    #[doc = ""]
    pub fn ovr_RequestBoundaryVisible(session: ovrSession, visible: ovrBool) -> ovrResult;
}
extern "C" {
    #[doc = " Returns the number of camera properties of all cameras"]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in, out] cameras Pointer to the array. If null and the provided array capacity is"]
    #[doc = " sufficient, will return ovrError_NullArrayPointer."]
    #[doc = " \\param[in, out] inoutCameraCount Supply the"]
    #[doc = " array capacity, will return the actual # of cameras defined. If *inoutCameraCount is too small,"]
    #[doc = " will return ovrError_InsufficientArraySize."]
    #[doc = " \\return Returns the list of external cameras the system knows about."]
    #[doc = " Returns ovrError_NoExternalCameraInfo if there is not any eternal camera information."]
    pub fn ovr_GetExternalCameras(
        session: ovrSession,
        cameras: *mut ovrExternalCamera,
        inoutCameraCount: *mut ::std::os::raw::c_uint,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Sets the camera intrinsics and/or extrinsics stored for the cameraName camera"]
    #[doc = " Names must be < 32 characters and null-terminated."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] name Specifies which camera to set the intrinsics or extrinsics for."]
    #[doc = " The name must be at most OVR_EXTERNAL_CAMERA_NAME_SIZE - 1"]
    #[doc = " characters. Otherwise, ovrError_ExternalCameraNameWrongSize is returned."]
    #[doc = " \\param[in] intrinsics Contains the intrinsic parameters to set, can be null"]
    #[doc = " \\param[in] extrinsics Contains the extrinsic parameters to set, can be null"]
    #[doc = " \\return Returns ovrSuccess or an ovrError code"]
    pub fn ovr_SetExternalCameraProperties(
        session: ovrSession,
        name: *const ::std::os::raw::c_char,
        intrinsics: *const ovrCameraIntrinsics,
        extrinsics: *const ovrCameraExtrinsics,
    ) -> ovrResult;
}
pub const ovrMaxLayerCount: _bindgen_ty_1 = 16;
#[doc = "  Specifies the maximum number of layers supported by ovr_SubmitFrame."]
#[doc = ""]
#[doc = "  /see ovr_SubmitFrame"]
#[doc = ""]
pub type _bindgen_ty_1 = i32;
#[doc = " Layer is disabled."]
pub const ovrLayerType__ovrLayerType_Disabled: ovrLayerType_ = 0;
#[doc = " Described by ovrLayerEyeFov."]
pub const ovrLayerType__ovrLayerType_EyeFov: ovrLayerType_ = 1;
#[doc = " Described by ovrLayerEyeFovDepth."]
pub const ovrLayerType__ovrLayerType_EyeFovDepth: ovrLayerType_ = 2;
#[doc = " Described by ovrLayerQuad. Previously called ovrLayerType_QuadInWorld."]
pub const ovrLayerType__ovrLayerType_Quad: ovrLayerType_ = 3;
#[doc = " Described by ovrLayerEyeMatrix."]
pub const ovrLayerType__ovrLayerType_EyeMatrix: ovrLayerType_ = 5;
#[doc = " Described by ovrLayerEyeFovMultires."]
pub const ovrLayerType__ovrLayerType_EyeFovMultires: ovrLayerType_ = 7;
#[doc = " Described by ovrLayerCylinder."]
pub const ovrLayerType__ovrLayerType_Cylinder: ovrLayerType_ = 8;
#[doc = " Described by ovrLayerCube"]
pub const ovrLayerType__ovrLayerType_Cube: ovrLayerType_ = 10;
#[doc = "< Force type int32_t."]
pub const ovrLayerType__ovrLayerType_EnumSize: ovrLayerType_ = 2147483647;
#[doc = " Describes layer types that can be passed to ovr_SubmitFrame."]
#[doc = " Each layer type has an associated struct, such as ovrLayerEyeFov."]
#[doc = ""]
#[doc = " \\see ovrLayerHeader"]
#[doc = ""]
pub type ovrLayerType_ = i32;
pub use self::ovrLayerType_ as ovrLayerType;
#[doc = " ovrLayerFlag_HighQuality enables 4x anisotropic sampling during the composition of the layer."]
#[doc = " The benefits are mostly visible at the periphery for high-frequency & high-contrast visuals."]
#[doc = " For best results consider combining this flag with an ovrTextureSwapChain that has mipmaps and"]
#[doc = " instead of using arbitrary sized textures, prefer texture sizes that are powers-of-two."]
#[doc = " Actual rendered viewport and doesn't necessarily have to fill the whole texture."]
pub const ovrLayerFlags__ovrLayerFlag_HighQuality: ovrLayerFlags_ = 1;
#[doc = " ovrLayerFlag_TextureOriginAtBottomLeft: the opposite is TopLeft."]
#[doc = " Generally this is false for D3D, true for OpenGL."]
pub const ovrLayerFlags__ovrLayerFlag_TextureOriginAtBottomLeft: ovrLayerFlags_ = 2;
#[doc = " Mark this surface as \"headlocked\", which means it is specified"]
#[doc = " relative to the HMD and moves with it, rather than being specified"]
#[doc = " relative to sensor/torso space and remaining still while the head moves."]
#[doc = " What used to be ovrLayerType_QuadHeadLocked is now ovrLayerType_Quad plus this flag."]
#[doc = " However the flag can be applied to any layer type to achieve a similar effect."]
pub const ovrLayerFlags__ovrLayerFlag_HeadLocked: ovrLayerFlags_ = 4;
#[doc = "< \\internal Force type int32_t."]
pub const ovrLayerFlags__ovrLayerFlags_EnumSize: ovrLayerFlags_ = 2147483647;
#[doc = " Identifies flags used by ovrLayerHeader and which are passed to ovr_SubmitFrame."]
#[doc = ""]
#[doc = " \\see ovrLayerHeader"]
#[doc = ""]
pub type ovrLayerFlags_ = i32;
pub use self::ovrLayerFlags_ as ovrLayerFlags;
#[doc = " Defines properties shared by all ovrLayer structs, such as ovrLayerEyeFov."]
#[doc = ""]
#[doc = " ovrLayerHeader is used as a base member in these larger structs."]
#[doc = " This struct cannot be used by itself except for the case that Type is ovrLayerType_Disabled."]
#[doc = ""]
#[doc = " \\see ovrLayerType, ovrLayerFlags"]
#[doc = ""]
pub type ovrLayerHeader = ovrLayerHeader_;
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct ovrLayerHeader_ {
    #[doc = "< Described by ovrLayerType."]
    pub Type: ovrLayerType,
    #[doc = "< Described by ovrLayerFlags."]
    pub Flags: ::std::os::raw::c_uint,
    pub Reserved: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_ovrLayerHeader_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerHeader_>(),
        136usize,
        concat!("Size of: ", stringify!(ovrLayerHeader_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerHeader_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerHeader_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader_>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader_>())).Reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader_),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = " Describes a layer that specifies a monoscopic or stereoscopic view."]
#[doc = " This is the kind of layer that's typically used as layer 0 to ovr_SubmitFrame,"]
#[doc = " as it is the kind of layer used to render a 3D stereoscopic view."]
#[doc = ""]
#[doc = " Three options exist with respect to mono/stereo texture usage:"]
#[doc = "    - ColorTexture[0] and ColorTexture[1] contain the left and right stereo renderings,"]
#[doc = "      respectively."]
#[doc = "      Viewport[0] and Viewport[1] refer to ColorTexture[0] and ColorTexture[1], respectively."]
#[doc = "    - ColorTexture[0] contains both the left and right renderings, ColorTexture[1] is NULL,"]
#[doc = "      and Viewport[0] and Viewport[1] refer to sub-rects with ColorTexture[0]."]
#[doc = "    - ColorTexture[0] contains a single monoscopic rendering, and Viewport[0] and"]
#[doc = "      Viewport[1] both refer to that rendering."]
#[doc = ""]
#[doc = " \\see ovrTextureSwapChain, ovr_SubmitFrame"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerEyeFov_ {
    #[doc = " Header.Type must be ovrLayerType_EyeFov."]
    pub Header: ovrLayerHeader,
    #[doc = " ovrTextureSwapChains for the left and right eye respectively."]
    #[doc = " The second one of which can be NULL for cases described above."]
    pub ColorTexture: [ovrTextureSwapChain; 2usize],
    #[doc = " Specifies the ColorTexture sub-rect UV coordinates."]
    #[doc = " Both Viewport[0] and Viewport[1] must be valid."]
    pub Viewport: [ovrRecti; 2usize],
    #[doc = " The viewport field of view."]
    pub Fov: [ovrFovPort; 2usize],
    #[doc = " Specifies the position and orientation of each eye view, with position specified in meters."]
    #[doc = " RenderPose will typically be the value returned from ovr_CalcEyePoses,"]
    #[doc = " but can be different in special cases if a different head pose is used for rendering."]
    pub RenderPose: [ovrPosef; 2usize],
    #[doc = " Specifies the timestamp when the source ovrPosef (used in calculating RenderPose)"]
    #[doc = " was sampled from the SDK. Typically retrieved by calling ovr_GetTimeInSeconds"]
    #[doc = " around the instant the application calls ovr_GetTrackingState"]
    #[doc = " The main purpose for this is to accurately track app tracking latency."]
    pub SensorSampleTime: f64,
}
#[test]
fn bindgen_test_layout_ovrLayerEyeFov_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerEyeFov_>(),
        280usize,
        concat!("Size of: ", stringify!(ovrLayerEyeFov_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerEyeFov_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerEyeFov_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeFov_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFov_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeFov_>())).ColorTexture as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFov_),
            "::",
            stringify!(ColorTexture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeFov_>())).Viewport as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFov_),
            "::",
            stringify!(Viewport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeFov_>())).Fov as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFov_),
            "::",
            stringify!(Fov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeFov_>())).RenderPose as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFov_),
            "::",
            stringify!(RenderPose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEyeFov_>())).SensorSampleTime as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFov_),
            "::",
            stringify!(SensorSampleTime)
        )
    );
}
pub type ovrLayerEyeFov = ovrLayerEyeFov_;
#[doc = " Describes a layer that specifies a monoscopic or stereoscopic view,"]
#[doc = " with depth textures in addition to color textures. This is typically used to support"]
#[doc = " positional time warp. This struct is the same as ovrLayerEyeFov, but with the addition"]
#[doc = " of DepthTexture and ProjectionDesc."]
#[doc = ""]
#[doc = " ProjectionDesc can be created using ovrTimewarpProjectionDesc_FromProjection."]
#[doc = ""]
#[doc = " Three options exist with respect to mono/stereo texture usage:"]
#[doc = "    - ColorTexture[0] and ColorTexture[1] contain the left and right stereo renderings,"]
#[doc = "      respectively."]
#[doc = "      Viewport[0] and Viewport[1] refer to ColorTexture[0] and ColorTexture[1], respectively."]
#[doc = "    - ColorTexture[0] contains both the left and right renderings, ColorTexture[1] is NULL,"]
#[doc = "      and Viewport[0] and Viewport[1] refer to sub-rects with ColorTexture[0]."]
#[doc = "    - ColorTexture[0] contains a single monoscopic rendering, and Viewport[0] and"]
#[doc = "      Viewport[1] both refer to that rendering."]
#[doc = ""]
#[doc = " \\see ovrTextureSwapChain, ovr_SubmitFrame"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerEyeFovDepth_ {
    #[doc = " Header.Type must be ovrLayerType_EyeFovDepth."]
    pub Header: ovrLayerHeader,
    #[doc = " ovrTextureSwapChains for the left and right eye respectively."]
    #[doc = " The second one of which can be NULL for cases described above."]
    pub ColorTexture: [ovrTextureSwapChain; 2usize],
    #[doc = " Specifies the ColorTexture sub-rect UV coordinates."]
    #[doc = " Both Viewport[0] and Viewport[1] must be valid."]
    pub Viewport: [ovrRecti; 2usize],
    #[doc = " The viewport field of view."]
    pub Fov: [ovrFovPort; 2usize],
    #[doc = " Specifies the position and orientation of each eye view, with position specified in meters."]
    #[doc = " RenderPose will typically be the value returned from ovr_CalcEyePoses,"]
    #[doc = " but can be different in special cases if a different head pose is used for rendering."]
    pub RenderPose: [ovrPosef; 2usize],
    #[doc = " Specifies the timestamp when the source ovrPosef (used in calculating RenderPose)"]
    #[doc = " was sampled from the SDK. Typically retrieved by calling ovr_GetTimeInSeconds"]
    #[doc = " around the instant the application calls ovr_GetTrackingState"]
    #[doc = " The main purpose for this is to accurately track app tracking latency."]
    pub SensorSampleTime: f64,
    #[doc = " Depth texture for depth composition with overlays"]
    #[doc = " Must map 1:1 to the ColorTexture."]
    pub DepthTexture: [ovrTextureSwapChain; 2usize],
    #[doc = " Specifies how to convert DepthTexture information into meters."]
    #[doc = " \\see ovrTimewarpProjectionDesc_FromProjection"]
    pub ProjectionDesc: ovrTimewarpProjectionDesc,
}
#[test]
fn bindgen_test_layout_ovrLayerEyeFovDepth_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerEyeFovDepth_>(),
        312usize,
        concat!("Size of: ", stringify!(ovrLayerEyeFovDepth_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerEyeFovDepth_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerEyeFovDepth_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeFovDepth_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovDepth_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEyeFovDepth_>())).ColorTexture as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovDepth_),
            "::",
            stringify!(ColorTexture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeFovDepth_>())).Viewport as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovDepth_),
            "::",
            stringify!(Viewport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeFovDepth_>())).Fov as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovDepth_),
            "::",
            stringify!(Fov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeFovDepth_>())).RenderPose as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovDepth_),
            "::",
            stringify!(RenderPose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEyeFovDepth_>())).SensorSampleTime as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovDepth_),
            "::",
            stringify!(SensorSampleTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEyeFovDepth_>())).DepthTexture as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovDepth_),
            "::",
            stringify!(DepthTexture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEyeFovDepth_>())).ProjectionDesc as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovDepth_),
            "::",
            stringify!(ProjectionDesc)
        )
    );
}
pub type ovrLayerEyeFovDepth = ovrLayerEyeFovDepth_;
#[doc = "< Regular eyeFov layer."]
pub const ovrTextureLayout__ovrTextureLayout_Rectilinear: ovrTextureLayout_ = 0;
#[doc = "< Octilinear extension must be enabled."]
pub const ovrTextureLayout__ovrTextureLayout_Octilinear: ovrTextureLayout_ = 1;
#[doc = "< \\internal Force type int32_t."]
pub const ovrTextureLayout__ovrTextureLayout_EnumSize: ovrTextureLayout_ = 2147483647;
#[doc = " Describes eye texture layouts. Used with ovrLayerEyeFovMultires."]
#[doc = ""]
pub type ovrTextureLayout_ = i32;
pub use self::ovrTextureLayout_ as ovrTextureLayout;
#[doc = " Multiresolution descriptor for Octilinear."]
#[doc = ""]
#[doc = " Usage of this layer must be successfully enabled via ovr_EnableExtension"]
#[doc = " before it can be used."]
#[doc = ""]
#[doc = " \\see ovrLayerEyeFovMultres"]
#[doc = ""]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ovrTextureLayoutOctilinear_ {
    pub WarpLeft: f32,
    pub WarpRight: f32,
    pub WarpUp: f32,
    pub WarpDown: f32,
    pub SizeLeft: f32,
    pub SizeRight: f32,
    pub SizeUp: f32,
    pub SizeDown: f32,
}
#[test]
fn bindgen_test_layout_ovrTextureLayoutOctilinear_() {
    assert_eq!(
        ::std::mem::size_of::<ovrTextureLayoutOctilinear_>(),
        32usize,
        concat!("Size of: ", stringify!(ovrTextureLayoutOctilinear_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTextureLayoutOctilinear_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrTextureLayoutOctilinear_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureLayoutOctilinear_>())).WarpLeft as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureLayoutOctilinear_),
            "::",
            stringify!(WarpLeft)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureLayoutOctilinear_>())).WarpRight as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureLayoutOctilinear_),
            "::",
            stringify!(WarpRight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureLayoutOctilinear_>())).WarpUp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureLayoutOctilinear_),
            "::",
            stringify!(WarpUp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureLayoutOctilinear_>())).WarpDown as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureLayoutOctilinear_),
            "::",
            stringify!(WarpDown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureLayoutOctilinear_>())).SizeLeft as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureLayoutOctilinear_),
            "::",
            stringify!(SizeLeft)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureLayoutOctilinear_>())).SizeRight as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureLayoutOctilinear_),
            "::",
            stringify!(SizeRight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureLayoutOctilinear_>())).SizeUp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureLayoutOctilinear_),
            "::",
            stringify!(SizeUp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureLayoutOctilinear_>())).SizeDown as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureLayoutOctilinear_),
            "::",
            stringify!(SizeDown)
        )
    );
}
pub type ovrTextureLayoutOctilinear = ovrTextureLayoutOctilinear_;
#[doc = " Combines texture layout descriptors."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ovrTextureLayoutDesc_Union_ {
    pub Octilinear: [ovrTextureLayoutOctilinear; 2usize],
    _bindgen_union_align: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_ovrTextureLayoutDesc_Union_() {
    assert_eq!(
        ::std::mem::size_of::<ovrTextureLayoutDesc_Union_>(),
        64usize,
        concat!("Size of: ", stringify!(ovrTextureLayoutDesc_Union_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTextureLayoutDesc_Union_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrTextureLayoutDesc_Union_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTextureLayoutDesc_Union_>())).Octilinear as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTextureLayoutDesc_Union_),
            "::",
            stringify!(Octilinear)
        )
    );
}
pub type ovrTextureLayoutDesc_Union = ovrTextureLayoutDesc_Union_;
#[doc = " Describes a layer that specifies a monoscopic or stereoscopic view with"]
#[doc = " support for optional multiresolution textures. This struct is the same as"]
#[doc = " ovrLayerEyeFov plus texture layout parameters."]
#[doc = ""]
#[doc = " Three options exist with respect to mono/stereo texture usage:"]
#[doc = "    - ColorTexture[0] and ColorTexture[1] contain the left and right stereo renderings,"]
#[doc = "      respectively."]
#[doc = "      Viewport[0] and Viewport[1] refer to ColorTexture[0] and ColorTexture[1], respectively."]
#[doc = "    - ColorTexture[0] contains both the left and right renderings, ColorTexture[1] is NULL,"]
#[doc = "      and Viewport[0] and Viewport[1] refer to sub-rects with ColorTexture[0]."]
#[doc = "    - ColorTexture[0] contains a single monoscopic rendering, and Viewport[0] and"]
#[doc = "      Viewport[1] both refer to that rendering."]
#[doc = ""]
#[doc = " \\see ovrTextureSwapChain, ovr_SubmitFrame"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerEyeFovMultires_ {
    #[doc = " Header.Type must be ovrLayerType_EyeFovMultires."]
    pub Header: ovrLayerHeader,
    #[doc = " ovrTextureSwapChains for the left and right eye respectively."]
    #[doc = " The second one of which can be NULL for cases described above."]
    pub ColorTexture: [ovrTextureSwapChain; 2usize],
    #[doc = " Specifies the ColorTexture sub-rect UV coordinates."]
    #[doc = " Both Viewport[0] and Viewport[1] must be valid."]
    pub Viewport: [ovrRecti; 2usize],
    #[doc = " The viewport field of view."]
    pub Fov: [ovrFovPort; 2usize],
    #[doc = " Specifies the position and orientation of each eye view, with position specified in meters."]
    #[doc = " RenderPose will typically be the value returned from ovr_CalcEyePoses,"]
    #[doc = " but can be different in special cases if a different head pose is used for rendering."]
    pub RenderPose: [ovrPosef; 2usize],
    #[doc = " Specifies the timestamp when the source ovrPosef (used in calculating RenderPose)"]
    #[doc = " was sampled from the SDK. Typically retrieved by calling ovr_GetTimeInSeconds"]
    #[doc = " around the instant the application calls ovr_GetTrackingState"]
    #[doc = " The main purpose for this is to accurately track app tracking latency."]
    pub SensorSampleTime: f64,
    #[doc = " Specifies layout type of textures."]
    pub TextureLayout: ovrTextureLayout,
    #[doc = " Specifies texture layout parameters."]
    pub TextureLayoutDesc: ovrTextureLayoutDesc_Union,
}
#[test]
fn bindgen_test_layout_ovrLayerEyeFovMultires_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerEyeFovMultires_>(),
        352usize,
        concat!("Size of: ", stringify!(ovrLayerEyeFovMultires_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerEyeFovMultires_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerEyeFovMultires_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeFovMultires_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovMultires_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEyeFovMultires_>())).ColorTexture as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovMultires_),
            "::",
            stringify!(ColorTexture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEyeFovMultires_>())).Viewport as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovMultires_),
            "::",
            stringify!(Viewport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeFovMultires_>())).Fov as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovMultires_),
            "::",
            stringify!(Fov)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEyeFovMultires_>())).RenderPose as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovMultires_),
            "::",
            stringify!(RenderPose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEyeFovMultires_>())).SensorSampleTime as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovMultires_),
            "::",
            stringify!(SensorSampleTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEyeFovMultires_>())).TextureLayout as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovMultires_),
            "::",
            stringify!(TextureLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEyeFovMultires_>())).TextureLayoutDesc as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeFovMultires_),
            "::",
            stringify!(TextureLayoutDesc)
        )
    );
}
pub type ovrLayerEyeFovMultires = ovrLayerEyeFovMultires_;
#[doc = " Describes a layer that specifies a monoscopic or stereoscopic view."]
#[doc = " This uses a direct 3x4 matrix to map from view space to the UV coordinates."]
#[doc = " It is essentially the same thing as ovrLayerEyeFov but using a much"]
#[doc = " lower level. This is mainly to provide compatibility with specific apps."]
#[doc = " Unless the application really requires this flexibility, it is usually better"]
#[doc = " to use ovrLayerEyeFov."]
#[doc = ""]
#[doc = " Three options exist with respect to mono/stereo texture usage:"]
#[doc = "    - ColorTexture[0] and ColorTexture[1] contain the left and right stereo renderings,"]
#[doc = "      respectively."]
#[doc = "      Viewport[0] and Viewport[1] refer to ColorTexture[0] and ColorTexture[1], respectively."]
#[doc = "    - ColorTexture[0] contains both the left and right renderings, ColorTexture[1] is NULL,"]
#[doc = "      and Viewport[0] and Viewport[1] refer to sub-rects with ColorTexture[0]."]
#[doc = "    - ColorTexture[0] contains a single monoscopic rendering, and Viewport[0] and"]
#[doc = "      Viewport[1] both refer to that rendering."]
#[doc = ""]
#[doc = " \\see ovrTextureSwapChain, ovr_SubmitFrame"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerEyeMatrix_ {
    #[doc = " Header.Type must be ovrLayerType_EyeMatrix."]
    pub Header: ovrLayerHeader,
    #[doc = " ovrTextureSwapChains for the left and right eye respectively."]
    #[doc = " The second one of which can be NULL for cases described above."]
    pub ColorTexture: [ovrTextureSwapChain; 2usize],
    #[doc = " Specifies the ColorTexture sub-rect UV coordinates."]
    #[doc = " Both Viewport[0] and Viewport[1] must be valid."]
    pub Viewport: [ovrRecti; 2usize],
    #[doc = " Specifies the position and orientation of each eye view, with position specified in meters."]
    #[doc = " RenderPose will typically be the value returned from ovr_CalcEyePoses,"]
    #[doc = " but can be different in special cases if a different head pose is used for rendering."]
    pub RenderPose: [ovrPosef; 2usize],
    #[doc = " Specifies the mapping from a view-space vector"]
    #[doc = " to a UV coordinate on the textures given above."]
    #[doc = " P = (x,y,z,1)*Matrix"]
    #[doc = " TexU  = P.x/P.z"]
    #[doc = " TexV  = P.y/P.z"]
    pub Matrix: [ovrMatrix4f; 2usize],
    #[doc = " Specifies the timestamp when the source ovrPosef (used in calculating RenderPose)"]
    #[doc = " was sampled from the SDK. Typically retrieved by calling ovr_GetTimeInSeconds"]
    #[doc = " around the instant the application calls ovr_GetTrackingState"]
    #[doc = " The main purpose for this is to accurately track app tracking latency."]
    pub SensorSampleTime: f64,
}
#[test]
fn bindgen_test_layout_ovrLayerEyeMatrix_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerEyeMatrix_>(),
        376usize,
        concat!("Size of: ", stringify!(ovrLayerEyeMatrix_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerEyeMatrix_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerEyeMatrix_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeMatrix_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeMatrix_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeMatrix_>())).ColorTexture as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeMatrix_),
            "::",
            stringify!(ColorTexture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeMatrix_>())).Viewport as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeMatrix_),
            "::",
            stringify!(Viewport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeMatrix_>())).RenderPose as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeMatrix_),
            "::",
            stringify!(RenderPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEyeMatrix_>())).Matrix as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeMatrix_),
            "::",
            stringify!(Matrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEyeMatrix_>())).SensorSampleTime as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEyeMatrix_),
            "::",
            stringify!(SensorSampleTime)
        )
    );
}
pub type ovrLayerEyeMatrix = ovrLayerEyeMatrix_;
#[doc = " Describes a layer of Quad type, which is a single quad in world or viewer space."]
#[doc = " It is used for ovrLayerType_Quad. This type of layer represents a single"]
#[doc = " object placed in the world and not a stereo view of the world itself."]
#[doc = ""]
#[doc = " A typical use of ovrLayerType_Quad is to draw a television screen in a room"]
#[doc = " that for some reason is more convenient to draw as a layer than as part of the main"]
#[doc = " view in layer 0. For example, it could implement a 3D popup GUI that is drawn at a"]
#[doc = " higher resolution than layer 0 to improve fidelity of the GUI."]
#[doc = ""]
#[doc = " Quad layers are visible from both sides; they are not back-face culled."]
#[doc = ""]
#[doc = " \\see ovrTextureSwapChain, ovr_SubmitFrame"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerQuad_ {
    #[doc = " Header.Type must be ovrLayerType_Quad."]
    pub Header: ovrLayerHeader,
    #[doc = " Contains a single image, never with any stereo view."]
    pub ColorTexture: ovrTextureSwapChain,
    #[doc = " Specifies the ColorTexture sub-rect UV coordinates."]
    pub Viewport: ovrRecti,
    #[doc = " Specifies the orientation and position of the center point of a Quad layer type."]
    #[doc = " The supplied direction is the vector perpendicular to the quad."]
    #[doc = " The position is in real-world meters (not the application's virtual world,"]
    #[doc = " the physical world the user is in) and is relative to the \"zero\" position"]
    #[doc = " set by ovr_RecenterTrackingOrigin unless the ovrLayerFlag_HeadLocked flag is used."]
    pub QuadPoseCenter: ovrPosef,
    #[doc = " Width and height (respectively) of the quad in meters."]
    pub QuadSize: ovrVector2f,
}
#[test]
fn bindgen_test_layout_ovrLayerQuad_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerQuad_>(),
        200usize,
        concat!("Size of: ", stringify!(ovrLayerQuad_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerQuad_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerQuad_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerQuad_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerQuad_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerQuad_>())).ColorTexture as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerQuad_),
            "::",
            stringify!(ColorTexture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerQuad_>())).Viewport as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerQuad_),
            "::",
            stringify!(Viewport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerQuad_>())).QuadPoseCenter as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerQuad_),
            "::",
            stringify!(QuadPoseCenter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerQuad_>())).QuadSize as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerQuad_),
            "::",
            stringify!(QuadSize)
        )
    );
}
pub type ovrLayerQuad = ovrLayerQuad_;
#[doc = " Describes a layer of type ovrLayerType_Cylinder which is a single cylinder"]
#[doc = " relative to the recentered origin. This type of layer represents a single"]
#[doc = " object placed in the world and not a stereo view of the world itself."]
#[doc = ""]
#[doc = "                -Z                                       +Y"]
#[doc = "         U=0  +--+--+  U=1"]
#[doc = "          +---+  |  +---+            +-----------------+  - V=0"]
#[doc = "       +--+ \\    |    / +--+         |                 |  |"]
#[doc = "     +-+     \\       /     +-+       |                 |  |"]
#[doc = "    ++        \\  A  /        ++      |                 |  |"]
#[doc = "   ++          \\---/          ++     |                 |  |"]
#[doc = "   |            \\ /            |     |              +X |  |"]
#[doc = "   +-------------C------R------+ +X  +--------C--------+  | <--- Height"]
#[doc = "       (+Y is out of screen)         |                 |  |"]
#[doc = "                                     |                 |  |"]
#[doc = "   R = Radius                        |                 |  |"]
#[doc = "   A = Angle (0,2*Pi)                |                 |  |"]
#[doc = "   C = CylinderPoseCenter            |                 |  |"]
#[doc = "   U/V = UV Coordinates              +-----------------+  - V=1"]
#[doc = ""]
#[doc = " An identity CylinderPoseCenter places the center of the cylinder"]
#[doc = " at the recentered origin unless the headlocked flag is set."]
#[doc = ""]
#[doc = " Does not utilize HmdSpaceToWorldScaleInMeters. If necessary, adjust"]
#[doc = " translation and radius."]
#[doc = ""]
#[doc = " \\note Only the interior surface of the cylinder is visible. Use cylinder"]
#[doc = " layers when the user cannot leave the extents of the cylinder. Artifacts may"]
#[doc = " appear when viewing the cylinder's exterior surface. Additionally, while the"]
#[doc = " interface supports an Angle that ranges from [0,2*Pi] the angle should"]
#[doc = " remain less than 1.9*PI to avoid artifacts where the cylinder edges"]
#[doc = " converge."]
#[doc = ""]
#[doc = " \\see ovrTextureSwapChain, ovr_SubmitFrame"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerCylinder_ {
    #[doc = " Header.Type must be ovrLayerType_Cylinder."]
    pub Header: ovrLayerHeader,
    #[doc = " Contains a single image, never with any stereo view."]
    pub ColorTexture: ovrTextureSwapChain,
    #[doc = " Specifies the ColorTexture sub-rect UV coordinates."]
    pub Viewport: ovrRecti,
    #[doc = " Specifies the orientation and position of the center point of a cylinder layer type."]
    #[doc = " The position is in real-world meters not the application's virtual world,"]
    #[doc = " but the physical world the user is in. It is relative to the \"zero\" position"]
    #[doc = " set by ovr_RecenterTrackingOrigin unless the ovrLayerFlag_HeadLocked flag is used."]
    pub CylinderPoseCenter: ovrPosef,
    #[doc = " Radius of the cylinder in meters."]
    pub CylinderRadius: f32,
    #[doc = " Angle in radians. Range is from 0 to 2*Pi exclusive covering the entire"]
    #[doc = " cylinder (see diagram and note above)."]
    pub CylinderAngle: f32,
    #[doc = " Custom aspect ratio presumably set based on 'Viewport'. Used to"]
    #[doc = " calculate the height of the cylinder based on the arc-length (CylinderAngle)"]
    #[doc = " and radius (CylinderRadius) given above. The height of the cylinder is"]
    #[doc = " given by: height = (CylinderRadius * CylinderAngle) / CylinderAspectRatio."]
    #[doc = " Aspect ratio is width / height."]
    pub CylinderAspectRatio: f32,
}
#[test]
fn bindgen_test_layout_ovrLayerCylinder_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCylinder_>(),
        200usize,
        concat!("Size of: ", stringify!(ovrLayerCylinder_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCylinder_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerCylinder_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCylinder_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCylinder_>())).ColorTexture as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder_),
            "::",
            stringify!(ColorTexture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCylinder_>())).Viewport as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder_),
            "::",
            stringify!(Viewport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder_>())).CylinderPoseCenter as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder_),
            "::",
            stringify!(CylinderPoseCenter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder_>())).CylinderRadius as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder_),
            "::",
            stringify!(CylinderRadius)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCylinder_>())).CylinderAngle as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder_),
            "::",
            stringify!(CylinderAngle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder_>())).CylinderAspectRatio as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder_),
            "::",
            stringify!(CylinderAspectRatio)
        )
    );
}
pub type ovrLayerCylinder = ovrLayerCylinder_;
#[doc = " Describes a layer of type ovrLayerType_Cube which is a single timewarped"]
#[doc = " cubemap at infinity. When looking down the recentered origin's -Z axis, +X"]
#[doc = " face is left and +Y face is up. Similarly, if headlocked the +X face is"]
#[doc = " left, +Y face is up and -Z face is forward. Note that the coordinate system"]
#[doc = " is left-handed."]
#[doc = ""]
#[doc = " ovrLayerFlag_TextureOriginAtBottomLeft flag is not supported by ovrLayerCube."]
#[doc = ""]
#[doc = " \\see ovrTextureSwapChain, ovr_SubmitFrame"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerCube_ {
    #[doc = " Header.Type must be ovrLayerType_Cube."]
    pub Header: ovrLayerHeader,
    #[doc = " Orientation of the cube."]
    pub Orientation: ovrQuatf,
    #[doc = " Contains a single cubemap swapchain (not a stereo pair of swapchains)."]
    pub CubeMapTexture: ovrTextureSwapChain,
}
#[test]
fn bindgen_test_layout_ovrLayerCube_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCube_>(),
        160usize,
        concat!("Size of: ", stringify!(ovrLayerCube_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCube_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerCube_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube_>())).Orientation as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube_),
            "::",
            stringify!(Orientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube_>())).CubeMapTexture as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube_),
            "::",
            stringify!(CubeMapTexture)
        )
    );
}
pub type ovrLayerCube = ovrLayerCube_;
#[doc = " Union that combines ovrLayer types in a way that allows them"]
#[doc = " to be used in a polymorphic way."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ovrLayer_Union_ {
    pub Header: ovrLayerHeader,
    pub EyeFov: ovrLayerEyeFov,
    pub EyeFovDepth: ovrLayerEyeFovDepth,
    pub Quad: ovrLayerQuad,
    pub EyeMatrix: ovrLayerEyeMatrix,
    pub Multires: ovrLayerEyeFovMultires,
    pub Cylinder: ovrLayerCylinder,
    pub Cube: ovrLayerCube,
    _bindgen_union_align: [u64; 47usize],
}
#[test]
fn bindgen_test_layout_ovrLayer_Union_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayer_Union_>(),
        376usize,
        concat!("Size of: ", stringify!(ovrLayer_Union_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayer_Union_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayer_Union_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union_>())).EyeFov as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union_),
            "::",
            stringify!(EyeFov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union_>())).EyeFovDepth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union_),
            "::",
            stringify!(EyeFovDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union_>())).Quad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union_),
            "::",
            stringify!(Quad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union_>())).EyeMatrix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union_),
            "::",
            stringify!(EyeMatrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union_>())).Multires as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union_),
            "::",
            stringify!(Multires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union_>())).Cylinder as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union_),
            "::",
            stringify!(Cylinder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union_>())).Cube as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union_),
            "::",
            stringify!(Cube)
        )
    );
}
pub type ovrLayer_Union = ovrLayer_Union_;
extern "C" {
    #[doc = " Gets the number of buffers in an ovrTextureSwapChain."]
    #[doc = ""]
    #[doc = " \\param[in]  session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in]  chain Specifies the ovrTextureSwapChain for which the length should be retrieved."]
    #[doc = " \\param[out] out_Length Returns the number of buffers in the specified chain."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error."]
    #[doc = ""]
    #[doc = " \\see ovr_CreateTextureSwapChainDX, ovr_CreateTextureSwapChainGL"]
    #[doc = ""]
    pub fn ovr_GetTextureSwapChainLength(
        session: ovrSession,
        chain: ovrTextureSwapChain,
        out_Length: *mut ::std::os::raw::c_int,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Gets the current index in an ovrTextureSwapChain."]
    #[doc = ""]
    #[doc = " \\param[in]  session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in]  chain Specifies the ovrTextureSwapChain for which the index should be retrieved."]
    #[doc = " \\param[out] out_Index Returns the current (free) index in specified chain."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error."]
    #[doc = ""]
    #[doc = " \\see ovr_CreateTextureSwapChainDX, ovr_CreateTextureSwapChainGL"]
    #[doc = ""]
    pub fn ovr_GetTextureSwapChainCurrentIndex(
        session: ovrSession,
        chain: ovrTextureSwapChain,
        out_Index: *mut ::std::os::raw::c_int,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Gets the description of the buffers in an ovrTextureSwapChain"]
    #[doc = ""]
    #[doc = " \\param[in]  session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in]  chain Specifies the ovrTextureSwapChain for which the description"]
    #[doc = "                   should be retrieved."]
    #[doc = " \\param[out] out_Desc Returns the description of the specified chain."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error."]
    #[doc = ""]
    #[doc = " \\see ovr_CreateTextureSwapChainDX, ovr_CreateTextureSwapChainGL"]
    #[doc = ""]
    pub fn ovr_GetTextureSwapChainDesc(
        session: ovrSession,
        chain: ovrTextureSwapChain,
        out_Desc: *mut ovrTextureSwapChainDesc,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Commits any pending changes to an ovrTextureSwapChain, and advances its current index"]
    #[doc = ""]
    #[doc = " \\param[in]  session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in]  chain Specifies the ovrTextureSwapChain to commit."]
    #[doc = ""]
    #[doc = " \\note When Commit is called, the texture at the current index is considered ready for use by the"]
    #[doc = " runtime, and further writes to it should be avoided. The swap chain's current index is advanced,"]
    #[doc = " providing there's room in the chain. The next time the SDK dereferences this texture swap chain,"]
    #[doc = " it will synchronize with the app's graphics context and pick up the submitted index, opening up"]
    #[doc = " room in the swap chain for further commits."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error."]
    #[doc = "         Failures include but aren't limited to:"]
    #[doc = "     - ovrError_TextureSwapChainFull: ovr_CommitTextureSwapChain was called too many times on a"]
    #[doc = "         texture swapchain without calling submit to use the chain."]
    #[doc = ""]
    #[doc = " \\see ovr_CreateTextureSwapChainDX, ovr_CreateTextureSwapChainGL"]
    #[doc = ""]
    pub fn ovr_CommitTextureSwapChain(session: ovrSession, chain: ovrTextureSwapChain)
        -> ovrResult;
}
extern "C" {
    #[doc = " Destroys an ovrTextureSwapChain and frees all the resources associated with it."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] chain Specifies the ovrTextureSwapChain to destroy. If it is NULL then"]
    #[doc = "            this function has no effect."]
    #[doc = ""]
    #[doc = " \\see ovr_CreateTextureSwapChainDX, ovr_CreateTextureSwapChainGL"]
    #[doc = ""]
    pub fn ovr_DestroyTextureSwapChain(session: ovrSession, chain: ovrTextureSwapChain);
}
extern "C" {
    #[doc = " Destroys a mirror texture previously created by one of the mirror texture creation functions."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] mirrorTexture Specifies the ovrTexture to destroy. If it is NULL then"]
    #[doc = "            this function has no effect."]
    #[doc = ""]
    #[doc = " \\see ovr_CreateMirrorTextureWithOptionsDX, ovr_CreateMirrorTextureWithOptionsGL"]
    #[doc = ""]
    pub fn ovr_DestroyMirrorTexture(session: ovrSession, mirrorTexture: ovrMirrorTexture);
}
extern "C" {
    #[doc = " Calculates the recommended viewport size for rendering a given eye within the HMD"]
    #[doc = " with a given FOV cone."]
    #[doc = ""]
    #[doc = " Higher FOV will generally require larger textures to maintain quality."]
    #[doc = " Apps packing multiple eye views together on the same texture should ensure there are"]
    #[doc = " at least 8 pixels of padding between them to prevent texture filtering and chromatic"]
    #[doc = " aberration causing images to leak between the two eye views."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] eye Specifies which eye (left or right) to calculate for."]
    #[doc = " \\param[in] fov Specifies the ovrFovPort to use."]
    #[doc = " \\param[in] pixelsPerDisplayPixel Specifies the ratio of the number of render target pixels"]
    #[doc = "            to display pixels at the center of distortion. 1.0 is the default value. Lower"]
    #[doc = "            values can improve performance, higher values give improved quality."]
    #[doc = ""]
    #[doc = " <b>Example code</b>"]
    #[doc = "     \\code{.cpp}"]
    #[doc = "         ovrHmdDesc hmdDesc = ovr_GetHmdDesc(session);"]
    #[doc = "         ovrSizei eyeSizeLeft  = ovr_GetFovTextureSize(session, ovrEye_Left,"]
    #[doc = "         hmdDesc.DefaultEyeFov[ovrEye_Left],  1.0f);"]
    #[doc = "         ovrSizei eyeSizeRight = ovr_GetFovTextureSize(session, ovrEye_Right,"]
    #[doc = "         hmdDesc.DefaultEyeFov[ovrEye_Right], 1.0f);"]
    #[doc = "     \\endcode"]
    #[doc = ""]
    #[doc = " \\return Returns the texture width and height size."]
    #[doc = ""]
    pub fn ovr_GetFovTextureSize(
        session: ovrSession,
        eye: ovrEyeType,
        fov: ovrFovPort,
        pixelsPerDisplayPixel: f32,
    ) -> ovrSizei;
}
extern "C" {
    #[doc = " Computes the distortion viewport, view adjust, and other rendering parameters for"]
    #[doc = " the specified eye."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] eyeType Specifies which eye (left or right) for which to perform calculations."]
    #[doc = " \\param[in] fov Specifies the ovrFovPort to use."]
    #[doc = ""]
    #[doc = " \\return Returns the computed ovrEyeRenderDesc for the given eyeType and field of view."]
    #[doc = ""]
    #[doc = " \\see ovrEyeRenderDesc"]
    #[doc = ""]
    pub fn ovr_GetRenderDesc(
        session: ovrSession,
        eyeType: ovrEyeType,
        fov: ovrFovPort,
    ) -> ovrEyeRenderDesc;
}
extern "C" {
    #[doc = " Waits until surfaces are available and it is time to begin rendering the frame.  Must be"]
    #[doc = " called before ovr_BeginFrame, but not necessarily from the same thread."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = ""]
    #[doc = " \\param[in] frameIndex Specifies the targeted application frame index."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success. Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: command completed successfully."]
    #[doc = "     - ovrSuccess_NotVisible: rendering of a previous frame completed successfully but was not"]
    #[doc = "       displayed on the HMD, usually because another application currently has ownership of the"]
    #[doc = "       HMD. Applications receiving this result should stop rendering new content and call"]
    #[doc = "       ovr_GetSessionStatus to detect visibility."]
    #[doc = "     - ovrError_DisplayLost: The session has become invalid (such as due to a device removal)"]
    #[doc = "       and the shared resources need to be released (ovr_DestroyTextureSwapChain), the session"]
    #[doc = "       needs to destroyed (ovr_Destroy) and recreated (ovr_Create), and new resources need to be"]
    #[doc = "       created (ovr_CreateTextureSwapChainXXX). The application's existing private graphics"]
    #[doc = "       resources do not need to be recreated unless the new ovr_Create call returns a different"]
    #[doc = "       GraphicsLuid."]
    #[doc = ""]
    #[doc = " \\see ovr_BeginFrame, ovr_EndFrame, ovr_GetSessionStatus"]
    #[doc = ""]
    pub fn ovr_WaitToBeginFrame(
        session: ovrSession,
        frameIndex: ::std::os::raw::c_longlong,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Called from render thread before application begins rendering.  Must be called after"]
    #[doc = " ovr_WaitToBeginFrame and before ovr_EndFrame, but not necessarily from the same threads."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = ""]
    #[doc = " \\param[in] frameIndex Specifies the targeted application frame index.  It must match what was"]
    #[doc = "        passed to ovr_WaitToBeginFrame."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success. Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: command completed successfully."]
    #[doc = "     - ovrError_DisplayLost: The session has become invalid (such as due to a device removal)"]
    #[doc = "       and the shared resources need to be released (ovr_DestroyTextureSwapChain), the session"]
    #[doc = "       needs to destroyed (ovr_Destroy) and recreated (ovr_Create), and new resources need to be"]
    #[doc = "       created (ovr_CreateTextureSwapChainXXX). The application's existing private graphics"]
    #[doc = "       resources do not need to be recreated unless the new ovr_Create call returns a different"]
    #[doc = "       GraphicsLuid."]
    #[doc = ""]
    #[doc = " \\see ovr_WaitToBeginFrame, ovr_EndFrame"]
    #[doc = ""]
    pub fn ovr_BeginFrame(session: ovrSession, frameIndex: ::std::os::raw::c_longlong)
        -> ovrResult;
}
extern "C" {
    #[doc = " Called from render thread after application has finished rendering.  Must be called after"]
    #[doc = " ovr_BeginFrame, but not necessarily from the same thread.  Submits layers for distortion and"]
    #[doc = " display, which will happen asynchronously."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = ""]
    #[doc = " \\param[in] frameIndex Specifies the targeted application frame index.  It must match what was"]
    #[doc = "        passed to ovr_BeginFrame."]
    #[doc = ""]
    #[doc = " \\param[in] viewScaleDesc Provides additional information needed only if layerPtrList contains"]
    #[doc = "        an ovrLayerType_Quad. If NULL, a default version is used based on the current"]
    #[doc = "        configuration and a 1.0 world scale."]
    #[doc = ""]
    #[doc = " \\param[in] layerPtrList Specifies a list of ovrLayer pointers, which can include NULL entries to"]
    #[doc = "        indicate that any previously shown layer at that index is to not be displayed."]
    #[doc = "        Each layer header must be a part of a layer structure such as ovrLayerEyeFov or"]
    #[doc = "        ovrLayerQuad, with Header.Type identifying its type. A NULL layerPtrList entry in the"]
    #[doc = "        array indicates the absence of the given layer."]
    #[doc = ""]
    #[doc = " \\param[in] layerCount Indicates the number of valid elements in layerPtrList. The maximum"]
    #[doc = "        supported layerCount is not currently specified, but may be specified in a future"]
    #[doc = "        version."]
    #[doc = ""]
    #[doc = " - Layers are drawn in the order they are specified in the array, regardless of the layer type."]
    #[doc = ""]
    #[doc = " - Layers are not remembered between successive calls to ovr_SubmitFrame. A layer must be"]
    #[doc = "   specified in every call to ovr_SubmitFrame or it won't be displayed."]
    #[doc = ""]
    #[doc = " - If a layerPtrList entry that was specified in a previous call to ovr_SubmitFrame is"]
    #[doc = "   passed as NULL or is of type ovrLayerType_Disabled, that layer is no longer displayed."]
    #[doc = ""]
    #[doc = " - A layerPtrList entry can be of any layer type and multiple entries of the same layer type"]
    #[doc = "   are allowed. No layerPtrList entry may be duplicated (i.e. the same pointer as an earlier"]
    #[doc = "   entry)."]
    #[doc = ""]
    #[doc = " <b>Example code</b>"]
    #[doc = "     \\code{.cpp}"]
    #[doc = "         ovrLayerEyeFov  layer0;"]
    #[doc = "         ovrLayerQuad    layer1;"]
    #[doc = "           ..."]
    #[doc = "         ovrLayerHeader* layers[2] = { &layer0.Header, &layer1.Header };"]
    #[doc = "         ovrResult result = ovr_EndFrame(session, frameIndex, nullptr, layers, 2);"]
    #[doc = "     \\endcode"]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success. Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: rendering completed successfully."]
    #[doc = "     - ovrError_DisplayLost: The session has become invalid (such as due to a device removal)"]
    #[doc = "       and the shared resources need to be released (ovr_DestroyTextureSwapChain), the session"]
    #[doc = "       needs to destroyed (ovr_Destroy) and recreated (ovr_Create), and new resources need to be"]
    #[doc = "       created (ovr_CreateTextureSwapChainXXX). The application's existing private graphics"]
    #[doc = "       resources do not need to be recreated unless the new ovr_Create call returns a different"]
    #[doc = "       GraphicsLuid."]
    #[doc = "     - ovrError_TextureSwapChainInvalid: The ovrTextureSwapChain is in an incomplete or"]
    #[doc = "       inconsistent state. Ensure ovr_CommitTextureSwapChain was called at least once first."]
    #[doc = ""]
    #[doc = " \\see ovr_WaitToBeginFrame, ovr_BeginFrame, ovrViewScaleDesc, ovrLayerHeader"]
    #[doc = ""]
    pub fn ovr_EndFrame(
        session: ovrSession,
        frameIndex: ::std::os::raw::c_longlong,
        viewScaleDesc: *const ovrViewScaleDesc,
        layerPtrList: *const *const ovrLayerHeader,
        layerCount: ::std::os::raw::c_uint,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Submits layers for distortion and display."]
    #[doc = ""]
    #[doc = " \\deprecated  Use ovr_WaitToBeginFrame, ovr_BeginFrame, and ovr_EndFrame instead."]
    #[doc = ""]
    #[doc = " ovr_SubmitFrame triggers distortion and processing which might happen asynchronously."]
    #[doc = " The function will return when there is room in the submission queue and surfaces"]
    #[doc = " are available. Distortion might or might not have completed."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = ""]
    #[doc = " \\param[in] frameIndex Specifies the targeted application frame index, or 0 to refer to one frame"]
    #[doc = "        after the last time ovr_SubmitFrame was called."]
    #[doc = ""]
    #[doc = " \\param[in] viewScaleDesc Provides additional information needed only if layerPtrList contains"]
    #[doc = "        an ovrLayerType_Quad. If NULL, a default version is used based on the current"]
    #[doc = "        configuration and a 1.0 world scale."]
    #[doc = ""]
    #[doc = " \\param[in] layerPtrList Specifies a list of ovrLayer pointers, which can include NULL entries to"]
    #[doc = "        indicate that any previously shown layer at that index is to not be displayed."]
    #[doc = "        Each layer header must be a part of a layer structure such as ovrLayerEyeFov or"]
    #[doc = "        ovrLayerQuad, with Header.Type identifying its type. A NULL layerPtrList entry in the"]
    #[doc = "        array indicates the absence of the given layer."]
    #[doc = ""]
    #[doc = " \\param[in] layerCount Indicates the number of valid elements in layerPtrList. The maximum"]
    #[doc = "        supported layerCount is not currently specified, but may be specified in a future"]
    #[doc = "        version."]
    #[doc = ""]
    #[doc = " - Layers are drawn in the order they are specified in the array, regardless of the layer type."]
    #[doc = ""]
    #[doc = " - Layers are not remembered between successive calls to ovr_SubmitFrame. A layer must be"]
    #[doc = "   specified in every call to ovr_SubmitFrame or it won't be displayed."]
    #[doc = ""]
    #[doc = " - If a layerPtrList entry that was specified in a previous call to ovr_SubmitFrame is"]
    #[doc = "   passed as NULL or is of type ovrLayerType_Disabled, that layer is no longer displayed."]
    #[doc = ""]
    #[doc = " - A layerPtrList entry can be of any layer type and multiple entries of the same layer type"]
    #[doc = "   are allowed. No layerPtrList entry may be duplicated (i.e. the same pointer as an earlier"]
    #[doc = "   entry)."]
    #[doc = ""]
    #[doc = " <b>Example code</b>"]
    #[doc = "     \\code{.cpp}"]
    #[doc = "         ovrLayerEyeFov  layer0;"]
    #[doc = "         ovrLayerQuad    layer1;"]
    #[doc = "           ..."]
    #[doc = "         ovrLayerHeader* layers[2] = { &layer0.Header, &layer1.Header };"]
    #[doc = "         ovrResult result = ovr_SubmitFrame(session, frameIndex, nullptr, layers, 2);"]
    #[doc = "     \\endcode"]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success. Return values include but aren't limited to:"]
    #[doc = "     - ovrSuccess: rendering completed successfully."]
    #[doc = "     - ovrSuccess_NotVisible: rendering completed successfully but was not displayed on the HMD,"]
    #[doc = "       usually because another application currently has ownership of the HMD. Applications"]
    #[doc = "       receiving this result should stop rendering new content, call ovr_GetSessionStatus"]
    #[doc = "       to detect visibility."]
    #[doc = "     - ovrError_DisplayLost: The session has become invalid (such as due to a device removal)"]
    #[doc = "       and the shared resources need to be released (ovr_DestroyTextureSwapChain), the session"]
    #[doc = "       needs to destroyed (ovr_Destroy) and recreated (ovr_Create), and new resources need to be"]
    #[doc = "       created (ovr_CreateTextureSwapChainXXX). The application's existing private graphics"]
    #[doc = "       resources do not need to be recreated unless the new ovr_Create call returns a different"]
    #[doc = "       GraphicsLuid."]
    #[doc = "     - ovrError_TextureSwapChainInvalid: The ovrTextureSwapChain is in an incomplete or"]
    #[doc = "       inconsistent state. Ensure ovr_CommitTextureSwapChain was called at least once first."]
    #[doc = ""]
    #[doc = " \\see ovr_GetPredictedDisplayTime, ovrViewScaleDesc, ovrLayerHeader, ovr_GetSessionStatus"]
    #[doc = ""]
    pub fn ovr_SubmitFrame(
        session: ovrSession,
        frameIndex: ::std::os::raw::c_longlong,
        viewScaleDesc: *const ovrViewScaleDesc,
        layerPtrList: *const *const ovrLayerHeader,
        layerCount: ::std::os::raw::c_uint,
    ) -> ovrResult;
}
#[doc = ""]
#[doc = " Contains the performance stats for a given SDK compositor frame"]
#[doc = ""]
#[doc = " All of the 'int' typed fields can be reset via the ovr_ResetPerfStats call."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrPerfStatsPerCompositorFrame_ {
    #[doc = " Vsync Frame Index - increments with each HMD vertical synchronization signal (i.e. vsync or"]
    #[doc = " refresh rate)"]
    #[doc = " If the compositor drops a frame, expect this value to increment more than 1 at a time."]
    pub HmdVsyncIndex: ::std::os::raw::c_int,
    #[doc = " Index that increments with each successive ovr_SubmitFrame call"]
    pub AppFrameIndex: ::std::os::raw::c_int,
    #[doc = " If the app fails to call ovr_SubmitFrame on time, then expect this value to increment with"]
    #[doc = " each missed frame"]
    pub AppDroppedFrameCount: ::std::os::raw::c_int,
    #[doc = " Motion-to-photon latency for the application"]
    #[doc = " This value is calculated by either using the SensorSampleTime provided for the ovrLayerEyeFov"]
    #[doc = " or if that"]
    #[doc = " is not available, then the call to ovr_GetTrackingState which has latencyMarker set to ovrTrue"]
    pub AppMotionToPhotonLatency: f32,
    #[doc = " Amount of queue-ahead in seconds provided to the app based on performance and overlap of"]
    #[doc = " CPU and  GPU utilization. A value of 0.0 would mean the CPU & GPU workload is being completed"]
    #[doc = " in 1 frame's worth of time, while 11 ms (on the CV1) of queue ahead would indicate that the"]
    #[doc = " app's CPU workload for the next frame is overlapping the GPU workload for the current frame."]
    pub AppQueueAheadTime: f32,
    #[doc = " Amount of time in seconds spent on the CPU by the app's render-thread that calls"]
    #[doc = " ovr_SubmitFram.  Measured as elapsed time between from when app regains control from"]
    #[doc = " ovr_SubmitFrame to the next time the app calls ovr_SubmitFrame."]
    pub AppCpuElapsedTime: f32,
    #[doc = " Amount of time in seconds spent on the GPU by the app."]
    #[doc = " Measured as elapsed time between each ovr_SubmitFrame call using GPU timing queries."]
    pub AppGpuElapsedTime: f32,
    #[doc = " Index that increments each time the SDK compositor completes a distortion and timewarp pass"]
    #[doc = " Since the compositor operates asynchronously, even if the app calls ovr_SubmitFrame too late,"]
    #[doc = " the compositor will kick off for each vsync."]
    pub CompositorFrameIndex: ::std::os::raw::c_int,
    #[doc = " Increments each time the SDK compositor fails to complete in time"]
    #[doc = " This is not tied to the app's performance, but failure to complete can be related to other"]
    #[doc = " factors such as OS capabilities, overall available hardware cycles to execute the compositor"]
    #[doc = " in time and other factors outside of the app's control."]
    pub CompositorDroppedFrameCount: ::std::os::raw::c_int,
    #[doc = " Motion-to-photon latency of the SDK compositor in seconds."]
    #[doc = " This is the latency of timewarp which corrects the higher app latency as well as dropped app"]
    #[doc = " frames."]
    pub CompositorLatency: f32,
    #[doc = " The amount of time in seconds spent on the CPU by the SDK compositor. Unless the"]
    #[doc = " VR app is utilizing all of the CPU cores at their peak performance, there is a good chance the"]
    #[doc = " compositor CPU times will not affect the app's CPU performance in a major way."]
    pub CompositorCpuElapsedTime: f32,
    #[doc = " The amount of time in seconds spent on the GPU by the SDK compositor. Any time spent on the"]
    #[doc = " compositor will eat away from the available GPU time for the app."]
    pub CompositorGpuElapsedTime: f32,
    #[doc = " The amount of time in seconds spent from the point the CPU kicks off the compositor to the"]
    #[doc = " point in time the compositor completes the distortion & timewarp on the GPU. In the event the"]
    #[doc = " GPU time is not available, expect this value to be -1.0f."]
    pub CompositorCpuStartToGpuEndElapsedTime: f32,
    #[doc = " The amount of time in seconds left after the compositor is done on the GPU to the associated"]
    #[doc = " V-Sync time. In the event the GPU time is not available, expect this value to be -1.0f."]
    pub CompositorGpuEndToVsyncElapsedTime: f32,
    #[doc = " Will be true if ASW is active for the given frame such that the application is being forced"]
    #[doc = " into half the frame-rate while the compositor continues to run at full frame-rate."]
    pub AswIsActive: ovrBool,
    #[doc = " Increments each time ASW it activated where the app was forced in and out of"]
    #[doc = " half-rate rendering."]
    pub AswActivatedToggleCount: ::std::os::raw::c_int,
    #[doc = " Accumulates the number of frames presented by the compositor which had extrapolated"]
    #[doc = " ASW frames presented."]
    pub AswPresentedFrameCount: ::std::os::raw::c_int,
    #[doc = " Accumulates the number of frames that the compositor tried to present when ASW is"]
    #[doc = " active but failed."]
    pub AswFailedFrameCount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrPerfStatsPerCompositorFrame_() {
    assert_eq!(
        ::std::mem::size_of::<ovrPerfStatsPerCompositorFrame_>(),
        72usize,
        concat!("Size of: ", stringify!(ovrPerfStatsPerCompositorFrame_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrPerfStatsPerCompositorFrame_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrPerfStatsPerCompositorFrame_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).HmdVsyncIndex as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(HmdVsyncIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).AppFrameIndex as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(AppFrameIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).AppDroppedFrameCount
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(AppDroppedFrameCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).AppMotionToPhotonLatency
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(AppMotionToPhotonLatency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).AppQueueAheadTime
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(AppQueueAheadTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).AppCpuElapsedTime
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(AppCpuElapsedTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).AppGpuElapsedTime
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(AppGpuElapsedTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).CompositorFrameIndex
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(CompositorFrameIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).CompositorDroppedFrameCount
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(CompositorDroppedFrameCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).CompositorLatency
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(CompositorLatency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).CompositorCpuElapsedTime
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(CompositorCpuElapsedTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).CompositorGpuElapsedTime
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(CompositorGpuElapsedTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>()))
                .CompositorCpuStartToGpuEndElapsedTime as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(CompositorCpuStartToGpuEndElapsedTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>()))
                .CompositorGpuEndToVsyncElapsedTime as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(CompositorGpuEndToVsyncElapsedTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).AswIsActive as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(AswIsActive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).AswActivatedToggleCount
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(AswActivatedToggleCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).AswPresentedFrameCount
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(AswPresentedFrameCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStatsPerCompositorFrame_>())).AswFailedFrameCount
                as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStatsPerCompositorFrame_),
            "::",
            stringify!(AswFailedFrameCount)
        )
    );
}
pub type ovrPerfStatsPerCompositorFrame = ovrPerfStatsPerCompositorFrame_;
pub const ovrMaxProvidedFrameStats: _bindgen_ty_2 = 5;
#[doc = ""]
#[doc = " Maximum number of frames of performance stats provided back to the caller of ovr_GetPerfStats"]
#[doc = ""]
pub type _bindgen_ty_2 = i32;
#[doc = ""]
#[doc = " This is a complete descriptor of the performance stats provided by the SDK"]
#[doc = ""]
#[doc = " \\see ovr_GetPerfStats, ovrPerfStatsPerCompositorFrame"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrPerfStats_ {
    #[doc = " FrameStatsCount will have a maximum value set by ovrMaxProvidedFrameStats"]
    #[doc = " If the application calls ovr_GetPerfStats at the native refresh rate of the HMD"]
    #[doc = " then FrameStatsCount will be 1. If the app's workload happens to force"]
    #[doc = " ovr_GetPerfStats to be called at a lower rate, then FrameStatsCount will be 2 or more."]
    #[doc = " If the app does not want to miss any performance data for any frame, it needs to"]
    #[doc = " ensure that it is calling ovr_SubmitFrame and ovr_GetPerfStats at a rate that is at least:"]
    #[doc = " \"HMD_refresh_rate / ovrMaxProvidedFrameStats\". On the Oculus Rift CV1 HMD, this will"]
    #[doc = " be equal to 18 times per second."]
    #[doc = ""]
    #[doc = " The performance entries will be ordered in reverse chronological order such that the"]
    #[doc = " first entry will be the most recent one."]
    pub FrameStats: [ovrPerfStatsPerCompositorFrame; 5usize],
    pub FrameStatsCount: ::std::os::raw::c_int,
    #[doc = " If the app calls ovr_GetPerfStats at less than 18 fps for CV1, then AnyFrameStatsDropped"]
    #[doc = " will be ovrTrue and FrameStatsCount will be equal to ovrMaxProvidedFrameStats."]
    pub AnyFrameStatsDropped: ovrBool,
    #[doc = " AdaptiveGpuPerformanceScale is an edge-filtered value that a caller can use to adjust"]
    #[doc = " the graphics quality of the application to keep the GPU utilization in check. The value"]
    #[doc = " is calculated as: (desired_GPU_utilization / current_GPU_utilization)"]
    #[doc = " As such, when this value is 1.0, the GPU is doing the right amount of work for the app."]
    #[doc = " Lower values mean the app needs to pull back on the GPU utilization."]
    #[doc = " If the app is going to directly drive render-target resolution using this value, then"]
    #[doc = " be sure to take the square-root of the value before scaling the resolution with it."]
    #[doc = " Changing render target resolutions however is one of the many things an app can do"]
    #[doc = " increase or decrease the amount of GPU utilization."]
    #[doc = " Since AdaptiveGpuPerformanceScale is edge-filtered and does not change rapidly"]
    #[doc = " (i.e. reports non-1.0 values once every couple of seconds) the app can make the"]
    #[doc = " necessary adjustments and then keep watching the value to see if it has been satisfied."]
    pub AdaptiveGpuPerformanceScale: f32,
    #[doc = " Will be true if Async Spacewarp (ASW) is available for this system which is dependent on"]
    #[doc = " several factors such as choice of GPU, OS and debug overrides"]
    pub AswIsAvailable: ovrBool,
    #[doc = " Contains the Process ID of the VR application the stats are being polled for"]
    #[doc = " If an app continues to grab perf stats even when it is not visible, then expect this"]
    #[doc = " value to point to the other VR app that has grabbed focus (i.e. became visible)"]
    pub VisibleProcessId: ovrProcessId,
}
#[test]
fn bindgen_test_layout_ovrPerfStats_() {
    assert_eq!(
        ::std::mem::size_of::<ovrPerfStats_>(),
        380usize,
        concat!("Size of: ", stringify!(ovrPerfStats_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrPerfStats_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrPerfStats_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPerfStats_>())).FrameStats as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStats_),
            "::",
            stringify!(FrameStats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPerfStats_>())).FrameStatsCount as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStats_),
            "::",
            stringify!(FrameStatsCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStats_>())).AnyFrameStatsDropped as *const _ as usize
        },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStats_),
            "::",
            stringify!(AnyFrameStatsDropped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerfStats_>())).AdaptiveGpuPerformanceScale as *const _
                as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStats_),
            "::",
            stringify!(AdaptiveGpuPerformanceScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPerfStats_>())).AswIsAvailable as *const _ as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStats_),
            "::",
            stringify!(AswIsAvailable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPerfStats_>())).VisibleProcessId as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerfStats_),
            "::",
            stringify!(VisibleProcessId)
        )
    );
}
pub type ovrPerfStats = ovrPerfStats_;
extern "C" {
    #[doc = " Retrieves performance stats for the VR app as well as the SDK compositor."]
    #[doc = ""]
    #[doc = " This function will return stats for the VR app that is currently visible in the HMD"]
    #[doc = " regardless of what VR app is actually calling this function."]
    #[doc = ""]
    #[doc = " If the VR app is trying to make sure the stats returned belong to the same application,"]
    #[doc = " the caller can compare the VisibleProcessId with their own process ID. Normally this will"]
    #[doc = " be the case if the caller is only calling ovr_GetPerfStats when ovr_GetSessionStatus has"]
    #[doc = " IsVisible flag set to be true."]
    #[doc = ""]
    #[doc = " If the VR app calling ovr_GetPerfStats is actually the one visible in the HMD,"]
    #[doc = " then new perf stats will only be populated after a new call to ovr_SubmitFrame."]
    #[doc = " That means subsequent calls to ovr_GetPerfStats after the first one without calling"]
    #[doc = " ovr_SubmitFrame will receive a FrameStatsCount of zero."]
    #[doc = ""]
    #[doc = " If the VR app is not visible, or was initially marked as ovrInit_Invisible, then each call"]
    #[doc = " to ovr_GetPerfStats will immediately fetch new perf stats from the compositor without"]
    #[doc = " a need for the ovr_SubmitFrame call."]
    #[doc = ""]
    #[doc = " Even though invisible VR apps do not require ovr_SubmitFrame to be called to gather new"]
    #[doc = " perf stats, since stats are generated at the native refresh rate of the HMD (i.e. 90 Hz"]
    #[doc = " for CV1), calling it at a higher rate than that would be unnecessary."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[out] outStats Contains the performance stats for the application and SDK compositor"]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success."]
    #[doc = ""]
    #[doc = " \\see ovrPerfStats, ovrPerfStatsPerCompositorFrame, ovr_ResetPerfStats"]
    #[doc = ""]
    pub fn ovr_GetPerfStats(session: ovrSession, outStats: *mut ovrPerfStats) -> ovrResult;
}
extern "C" {
    #[doc = " Resets the accumulated stats reported in each ovrPerfStatsPerCompositorFrame back to zero."]
    #[doc = ""]
    #[doc = " Only the integer values such as HmdVsyncIndex, AppDroppedFrameCount etc. will be reset"]
    #[doc = " as the other fields such as AppMotionToPhotonLatency are independent timing values updated"]
    #[doc = " per-frame."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\return Returns an ovrResult for which OVR_SUCCESS(result) is false upon error and true"]
    #[doc = "         upon success."]
    #[doc = ""]
    #[doc = " \\see ovrPerfStats, ovrPerfStatsPerCompositorFrame, ovr_GetPerfStats"]
    #[doc = ""]
    pub fn ovr_ResetPerfStats(session: ovrSession) -> ovrResult;
}
extern "C" {
    #[doc = " Gets the time of the specified frame midpoint."]
    #[doc = ""]
    #[doc = " Predicts the time at which the given frame will be displayed. The predicted time"]
    #[doc = " is the middle of the time period during which the corresponding eye images will"]
    #[doc = " be displayed."]
    #[doc = ""]
    #[doc = " The application should increment frameIndex for each successively targeted frame,"]
    #[doc = " and pass that index to any relevant OVR functions that need to apply to the frame"]
    #[doc = " identified by that index."]
    #[doc = ""]
    #[doc = " This function is thread-safe and allows for multiple application threads to target"]
    #[doc = " their processing to the same displayed frame."]
    #[doc = ""]
    #[doc = " In the even that prediction fails due to various reasons (e.g. the display being off"]
    #[doc = " or app has yet to present any frames), the return value will be current CPU time."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] frameIndex Identifies the frame the caller wishes to target."]
    #[doc = "            A value of zero returns the next frame index."]
    #[doc = " \\return Returns the absolute frame midpoint time for the given frameIndex."]
    #[doc = " \\see ovr_GetTimeInSeconds"]
    #[doc = ""]
    pub fn ovr_GetPredictedDisplayTime(
        session: ovrSession,
        frameIndex: ::std::os::raw::c_longlong,
    ) -> f64;
}
extern "C" {
    #[doc = " Returns global, absolute high-resolution time in seconds."]
    #[doc = ""]
    #[doc = " The time frame of reference for this function is not specified and should not be"]
    #[doc = " depended upon."]
    #[doc = ""]
    #[doc = " \\return Returns seconds as a floating point value."]
    #[doc = " \\see ovrPoseStatef, ovrFrameTiming"]
    #[doc = ""]
    pub fn ovr_GetTimeInSeconds() -> f64;
}
#[doc = "< Turns off the performance HUD"]
pub const ovrPerfHudMode__ovrPerfHud_Off: ovrPerfHudMode_ = 0;
#[doc = "< Shows performance summary and headroom"]
pub const ovrPerfHudMode__ovrPerfHud_PerfSummary: ovrPerfHudMode_ = 1;
#[doc = "< Shows latency related timing info"]
pub const ovrPerfHudMode__ovrPerfHud_LatencyTiming: ovrPerfHudMode_ = 2;
#[doc = "< Shows render timing info for application"]
pub const ovrPerfHudMode__ovrPerfHud_AppRenderTiming: ovrPerfHudMode_ = 3;
#[doc = "< Shows render timing info for OVR compositor"]
pub const ovrPerfHudMode__ovrPerfHud_CompRenderTiming: ovrPerfHudMode_ = 4;
#[doc = "< Shows Async Spacewarp-specific info"]
pub const ovrPerfHudMode__ovrPerfHud_AswStats: ovrPerfHudMode_ = 6;
#[doc = "< Shows SDK & HMD version Info"]
pub const ovrPerfHudMode__ovrPerfHud_VersionInfo: ovrPerfHudMode_ = 5;
#[doc = "< \\internal Count of enumerated elements."]
pub const ovrPerfHudMode__ovrPerfHud_Count: ovrPerfHudMode_ = 7;
#[doc = "< \\internal Force type int32_t."]
pub const ovrPerfHudMode__ovrPerfHud_EnumSize: ovrPerfHudMode_ = 2147483647;
#[doc = " Performance HUD enables the HMD user to see information critical to"]
#[doc = " the real-time operation of the VR application such as latency timing,"]
#[doc = " and CPU & GPU performance metrics"]
#[doc = ""]
#[doc = "     App can toggle performance HUD modes as such:"]
#[doc = "     \\code{.cpp}"]
#[doc = "         ovrPerfHudMode PerfHudMode = ovrPerfHud_LatencyTiming;"]
#[doc = "         ovr_SetInt(session, OVR_PERF_HUD_MODE, (int)PerfHudMode);"]
#[doc = "     \\endcode"]
#[doc = ""]
pub type ovrPerfHudMode_ = i32;
pub use self::ovrPerfHudMode_ as ovrPerfHudMode;
#[doc = "< Turns off the layer HUD"]
pub const ovrLayerHudMode__ovrLayerHud_Off: ovrLayerHudMode_ = 0;
#[doc = "< Shows info about a specific layer"]
pub const ovrLayerHudMode__ovrLayerHud_Info: ovrLayerHudMode_ = 1;
pub const ovrLayerHudMode__ovrLayerHud_EnumSize: ovrLayerHudMode_ = 2147483647;
#[doc = " Layer HUD enables the HMD user to see information about a layer"]
#[doc = ""]
#[doc = "     App can toggle layer HUD modes as such:"]
#[doc = "     \\code{.cpp}"]
#[doc = "         ovrLayerHudMode LayerHudMode = ovrLayerHud_Info;"]
#[doc = "         ovr_SetInt(session, OVR_LAYER_HUD_MODE, (int)LayerHudMode);"]
#[doc = "     \\endcode"]
#[doc = ""]
pub type ovrLayerHudMode_ = i32;
pub use self::ovrLayerHudMode_ as ovrLayerHudMode;
#[doc = " Turns off the Stereo Debug HUD."]
pub const ovrDebugHudStereoMode__ovrDebugHudStereo_Off: ovrDebugHudStereoMode_ = 0;
#[doc = " Renders Quad in world for Stereo Debugging."]
pub const ovrDebugHudStereoMode__ovrDebugHudStereo_Quad: ovrDebugHudStereoMode_ = 1;
#[doc = " Renders Quad+crosshair in world for Stereo Debugging"]
pub const ovrDebugHudStereoMode__ovrDebugHudStereo_QuadWithCrosshair: ovrDebugHudStereoMode_ = 2;
#[doc = " Renders screen-space crosshair at infinity for Stereo Debugging"]
pub const ovrDebugHudStereoMode__ovrDebugHudStereo_CrosshairAtInfinity: ovrDebugHudStereoMode_ = 3;
#[doc = " \\internal Count of enumerated elements"]
pub const ovrDebugHudStereoMode__ovrDebugHudStereo_Count: ovrDebugHudStereoMode_ = 4;
#[doc = "< \\internal Force type int32_t"]
pub const ovrDebugHudStereoMode__ovrDebugHudStereo_EnumSize: ovrDebugHudStereoMode_ = 2147483647;
#[doc = " Debug HUD is provided to help developers gauge and debug the fidelity of their app's"]
#[doc = " stereo rendering characteristics. Using the provided quad and crosshair guides,"]
#[doc = " the developer can verify various aspects such as VR tracking units (e.g. meters),"]
#[doc = " stereo camera-parallax properties (e.g. making sure objects at infinity are rendered"]
#[doc = " with the proper separation), measuring VR geometry sizes and distances and more."]
#[doc = ""]
#[doc = "     App can toggle the debug HUD modes as such:"]
#[doc = "     \\code{.cpp}"]
#[doc = "         ovrDebugHudStereoMode DebugHudMode = ovrDebugHudStereo_QuadWithCrosshair;"]
#[doc = "         ovr_SetInt(session, OVR_DEBUG_HUD_STEREO_MODE, (int)DebugHudMode);"]
#[doc = "     \\endcode"]
#[doc = ""]
#[doc = " The app can modify the visual properties of the stereo guide (i.e. quad, crosshair)"]
#[doc = " using the ovr_SetFloatArray function. For a list of tweakable properties,"]
#[doc = " see the OVR_DEBUG_HUD_STEREO_GUIDE_* keys in the OVR_CAPI_Keys.h header file."]
pub type ovrDebugHudStereoMode_ = i32;
pub use self::ovrDebugHudStereoMode_ as ovrDebugHudStereoMode;
extern "C" {
    #[doc = " Reads a boolean property."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] propertyName The name of the property, which needs to be valid for only the call."]
    #[doc = " \\param[in] defaultVal specifes the value to return if the property couldn't be read."]
    #[doc = " \\return Returns the property interpreted as a boolean value. Returns defaultVal if"]
    #[doc = "         the property doesn't exist."]
    pub fn ovr_GetBool(
        session: ovrSession,
        propertyName: *const ::std::os::raw::c_char,
        defaultVal: ovrBool,
    ) -> ovrBool;
}
extern "C" {
    #[doc = " Writes or creates a boolean property."]
    #[doc = " If the property wasn't previously a boolean property, it is changed to a boolean property."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] propertyName The name of the property, which needs to be valid only for the call."]
    #[doc = " \\param[in] value The value to write."]
    #[doc = " \\return Returns true if successful, otherwise false. A false result should only occur if the"]
    #[doc = " property"]
    #[doc = "         name is empty or if the property is read-only."]
    pub fn ovr_SetBool(
        session: ovrSession,
        propertyName: *const ::std::os::raw::c_char,
        value: ovrBool,
    ) -> ovrBool;
}
extern "C" {
    #[doc = " Reads an integer property."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] propertyName The name of the property, which needs to be valid only for the call."]
    #[doc = " \\param[in] defaultVal Specifes the value to return if the property couldn't be read."]
    #[doc = " \\return Returns the property interpreted as an integer value. Returns defaultVal if"]
    #[doc = "         the property doesn't exist."]
    pub fn ovr_GetInt(
        session: ovrSession,
        propertyName: *const ::std::os::raw::c_char,
        defaultVal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes or creates an integer property."]
    #[doc = ""]
    #[doc = " If the property wasn't previously a boolean property, it is changed to an integer property."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] propertyName The name of the property, which needs to be valid only for the call."]
    #[doc = " \\param[in] value The value to write."]
    #[doc = " \\return Returns true if successful, otherwise false. A false result should only occur if the"]
    #[doc = "         property name is empty or if the property is read-only."]
    pub fn ovr_SetInt(
        session: ovrSession,
        propertyName: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> ovrBool;
}
extern "C" {
    #[doc = " Reads a float property."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] propertyName The name of the property, which needs to be valid only for the call."]
    #[doc = " \\param[in] defaultVal specifes the value to return if the property couldn't be read."]
    #[doc = " \\return Returns the property interpreted as an float value. Returns defaultVal if"]
    #[doc = "         the property doesn't exist."]
    pub fn ovr_GetFloat(
        session: ovrSession,
        propertyName: *const ::std::os::raw::c_char,
        defaultVal: f32,
    ) -> f32;
}
extern "C" {
    #[doc = " Writes or creates a float property."]
    #[doc = " If the property wasn't previously a float property, it's changed to a float property."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] propertyName The name of the property, which needs to be valid only for the call."]
    #[doc = " \\param[in] value The value to write."]
    #[doc = " \\return Returns true if successful, otherwise false. A false result should only occur if the"]
    #[doc = "         property name is empty or if the property is read-only."]
    pub fn ovr_SetFloat(
        session: ovrSession,
        propertyName: *const ::std::os::raw::c_char,
        value: f32,
    ) -> ovrBool;
}
extern "C" {
    #[doc = " Reads a float array property."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] propertyName The name of the property, which needs to be valid only for the call."]
    #[doc = " \\param[in] values An array of float to write to."]
    #[doc = " \\param[in] valuesCapacity Specifies the maximum number of elements to write to the values array."]
    #[doc = " \\return Returns the number of elements read, or 0 if property doesn't exist or is empty."]
    pub fn ovr_GetFloatArray(
        session: ovrSession,
        propertyName: *const ::std::os::raw::c_char,
        values: *mut f32,
        valuesCapacity: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Writes or creates a float array property."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] propertyName The name of the property, which needs to be valid only for the call."]
    #[doc = " \\param[in] values An array of float to write from."]
    #[doc = " \\param[in] valuesSize Specifies the number of elements to write."]
    #[doc = " \\return Returns true if successful, otherwise false. A false result should only occur if the"]
    #[doc = "         property name is empty or if the property is read-only."]
    pub fn ovr_SetFloatArray(
        session: ovrSession,
        propertyName: *const ::std::os::raw::c_char,
        values: *const f32,
        valuesSize: ::std::os::raw::c_uint,
    ) -> ovrBool;
}
extern "C" {
    #[doc = " Reads a string property."]
    #[doc = " Strings are UTF8-encoded and null-terminated."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] propertyName The name of the property, which needs to be valid only for the call."]
    #[doc = " \\param[in] defaultVal Specifes the value to return if the property couldn't be read."]
    #[doc = " \\return Returns the string property if it exists. Otherwise returns defaultVal, which can be"]
    #[doc = "         specified as NULL. The return memory is guaranteed to be valid until next call to"]
    #[doc = "         ovr_GetString or until the session is destroyed, whichever occurs first."]
    pub fn ovr_GetString(
        session: ovrSession,
        propertyName: *const ::std::os::raw::c_char,
        defaultVal: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Writes or creates a string property."]
    #[doc = " Strings are UTF8-encoded and null-terminated."]
    #[doc = ""]
    #[doc = " \\param[in] session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in] propertyName The name of the property, which needs to be valid only for the call."]
    #[doc = " \\param[in] value The string property, which only needs to be valid for the duration of the call."]
    #[doc = " \\return Returns true if successful, otherwise false. A false result should only occur if the"]
    #[doc = "         property name is empty or if the property is read-only."]
    pub fn ovr_SetString(
        session: ovrSession,
        propertyName: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ovrBool;
}
pub type staticAssert0 = [::std::os::raw::c_char; 1usize];
#[doc = " Use for generating a default projection matrix that is:"]
#[doc = " * Right-handed."]
#[doc = " * Near depth values stored in the depth buffer are smaller than far depth values."]
#[doc = " * Both near and far are explicitly defined."]
#[doc = " * With a clipping range that is (0 to w)."]
pub const ovrProjectionModifier__ovrProjection_None: ovrProjectionModifier_ = 0;
#[doc = " Enable if using left-handed transformations in your application."]
pub const ovrProjectionModifier__ovrProjection_LeftHanded: ovrProjectionModifier_ = 1;
#[doc = " After the projection transform is applied, far values stored in the depth buffer will be less"]
#[doc = " than closer depth values."]
#[doc = " NOTE: Enable only if the application is using a floating-point depth buffer for proper"]
#[doc = " precision."]
pub const ovrProjectionModifier__ovrProjection_FarLessThanNear: ovrProjectionModifier_ = 2;
#[doc = " When this flag is used, the zfar value pushed into ovrMatrix4f_Projection() will be ignored"]
#[doc = " NOTE: Enable only if ovrProjection_FarLessThanNear is also enabled where the far clipping"]
#[doc = " plane will be pushed to infinity."]
pub const ovrProjectionModifier__ovrProjection_FarClipAtInfinity: ovrProjectionModifier_ = 4;
#[doc = " Enable if the application is rendering with OpenGL and expects a projection matrix with a"]
#[doc = " clipping range of (-w to w)."]
#[doc = " Ignore this flag if your application already handles the conversion from D3D range (0 to w) to"]
#[doc = " OpenGL."]
pub const ovrProjectionModifier__ovrProjection_ClipRangeOpenGL: ovrProjectionModifier_ = 8;
#[doc = " Enumerates modifications to the projection matrix based on the application's needs."]
#[doc = ""]
#[doc = " \\see ovrMatrix4f_Projection"]
#[doc = ""]
pub type ovrProjectionModifier_ = i32;
pub use self::ovrProjectionModifier_ as ovrProjectionModifier;
#[doc = " Return values for ovr_Detect."]
#[doc = ""]
#[doc = " \\see ovr_Detect"]
#[doc = ""]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ovrDetectResult_ {
    #[doc = " Is ovrFalse when the Oculus Service is not running."]
    #[doc = "   This means that the Oculus Service is either uninstalled or stopped."]
    #[doc = "   IsOculusHMDConnected will be ovrFalse in this case."]
    #[doc = " Is ovrTrue when the Oculus Service is running."]
    #[doc = "   This means that the Oculus Service is installed and running."]
    #[doc = "   IsOculusHMDConnected will reflect the state of the HMD."]
    pub IsOculusServiceRunning: ovrBool,
    #[doc = " Is ovrFalse when an Oculus HMD is not detected."]
    #[doc = "   If the Oculus Service is not running, this will be ovrFalse."]
    #[doc = " Is ovrTrue when an Oculus HMD is detected."]
    #[doc = "   This implies that the Oculus Service is also installed and running."]
    pub IsOculusHMDConnected: ovrBool,
    pub pad0: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout_ovrDetectResult_() {
    assert_eq!(
        ::std::mem::size_of::<ovrDetectResult_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrDetectResult_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrDetectResult_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrDetectResult_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrDetectResult_>())).IsOculusServiceRunning as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrDetectResult_),
            "::",
            stringify!(IsOculusServiceRunning)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrDetectResult_>())).IsOculusHMDConnected as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrDetectResult_),
            "::",
            stringify!(IsOculusHMDConnected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrDetectResult_>())).pad0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrDetectResult_),
            "::",
            stringify!(pad0)
        )
    );
}
pub type ovrDetectResult = ovrDetectResult_;
pub type staticAssert1 = [::std::os::raw::c_char; 1usize];
#[doc = " Point sample original signal at Haptics frequency"]
pub const ovrHapticsGenMode__ovrHapticsGenMode_PointSample: ovrHapticsGenMode_ = 0;
#[doc = " Point sample original signal at Haptics frequency"]
pub const ovrHapticsGenMode__ovrHapticsGenMode_Count: ovrHapticsGenMode_ = 1;
#[doc = " Modes used to generate Touch Haptics from audio PCM buffer."]
#[doc = ""]
pub type ovrHapticsGenMode_ = i32;
pub use self::ovrHapticsGenMode_ as ovrHapticsGenMode;
#[doc = " Store audio PCM data (as 32b float samples) for an audio channel."]
#[doc = " Note: needs to be released with ovr_ReleaseAudioChannelData to avoid memory leak."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrAudioChannelData_ {
    #[doc = " Samples stored as floats [-1.0f, 1.0f]."]
    pub Samples: *const f32,
    #[doc = " Number of samples"]
    pub SamplesCount: ::std::os::raw::c_int,
    #[doc = " Frequency (e.g. 44100)"]
    pub Frequency: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrAudioChannelData_() {
    assert_eq!(
        ::std::mem::size_of::<ovrAudioChannelData_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrAudioChannelData_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrAudioChannelData_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrAudioChannelData_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrAudioChannelData_>())).Samples as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrAudioChannelData_),
            "::",
            stringify!(Samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrAudioChannelData_>())).SamplesCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrAudioChannelData_),
            "::",
            stringify!(SamplesCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrAudioChannelData_>())).Frequency as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrAudioChannelData_),
            "::",
            stringify!(Frequency)
        )
    );
}
pub type ovrAudioChannelData = ovrAudioChannelData_;
#[doc = " Store a full Haptics clip, which can be used as data source for multiple ovrHapticsBuffers."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrHapticsClip_ {
    #[doc = " Samples stored in opaque format"]
    pub Samples: *const ::std::os::raw::c_void,
    #[doc = " Number of samples"]
    pub SamplesCount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrHapticsClip_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHapticsClip_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrHapticsClip_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHapticsClip_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrHapticsClip_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticsClip_>())).Samples as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticsClip_),
            "::",
            stringify!(Samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticsClip_>())).SamplesCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticsClip_),
            "::",
            stringify!(SamplesCount)
        )
    );
}
pub type ovrHapticsClip = ovrHapticsClip_;
extern "C" {
    #[doc = " Detects Oculus Runtime and Device Status"]
    #[doc = ""]
    #[doc = " Checks for Oculus Runtime and Oculus HMD device status without loading the LibOVRRT"]
    #[doc = " shared library.  This may be called before ovr_Initialize() to help decide whether or"]
    #[doc = " not to initialize LibOVR."]
    #[doc = ""]
    #[doc = " \\param[in] timeoutMilliseconds Specifies a timeout to wait for HMD to be attached or 0 to poll."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrDetectResult object indicating the result of detection."]
    #[doc = ""]
    #[doc = " \\see ovrDetectResult"]
    #[doc = ""]
    pub fn ovr_Detect(timeoutMilliseconds: ::std::os::raw::c_int) -> ovrDetectResult;
}
extern "C" {
    #[doc = " Used to generate projection from ovrEyeDesc::Fov."]
    #[doc = ""]
    #[doc = " \\param[in] fov Specifies the ovrFovPort to use."]
    #[doc = " \\param[in] znear Distance to near Z limit."]
    #[doc = " \\param[in] zfar Distance to far Z limit."]
    #[doc = " \\param[in] projectionModFlags A combination of the ovrProjectionModifier flags."]
    #[doc = ""]
    #[doc = " \\return Returns the calculated projection matrix."]
    #[doc = ""]
    #[doc = " \\see ovrProjectionModifier"]
    #[doc = ""]
    pub fn ovrMatrix4f_Projection(
        fov: ovrFovPort,
        znear: f32,
        zfar: f32,
        projectionModFlags: ::std::os::raw::c_uint,
    ) -> ovrMatrix4f;
}
extern "C" {
    #[doc = " Extracts the required data from the result of ovrMatrix4f_Projection."]
    #[doc = ""]
    #[doc = " \\param[in] projection Specifies the project matrix from which to"]
    #[doc = "            extract ovrTimewarpProjectionDesc."]
    #[doc = " \\param[in] projectionModFlags A combination of the ovrProjectionModifier flags."]
    #[doc = " \\return Returns the extracted ovrTimewarpProjectionDesc."]
    #[doc = " \\see ovrTimewarpProjectionDesc"]
    #[doc = ""]
    pub fn ovrTimewarpProjectionDesc_FromProjection(
        projection: ovrMatrix4f,
        projectionModFlags: ::std::os::raw::c_uint,
    ) -> ovrTimewarpProjectionDesc;
}
extern "C" {
    #[doc = " Generates an orthographic sub-projection."]
    #[doc = ""]
    #[doc = " Used for 2D rendering, Y is down."]
    #[doc = ""]
    #[doc = " \\param[in] projection The perspective matrix that the orthographic matrix is derived from."]
    #[doc = " \\param[in] orthoScale Equal to 1.0f / pixelsPerTanAngleAtCenter."]
    #[doc = " \\param[in] orthoDistance Equal to the distance from the camera in meters, such as 0.8m."]
    #[doc = " \\param[in] HmdToEyeOffsetX Specifies the offset of the eye from the center."]
    #[doc = ""]
    #[doc = " \\return Returns the calculated projection matrix."]
    #[doc = ""]
    pub fn ovrMatrix4f_OrthoSubProjection(
        projection: ovrMatrix4f,
        orthoScale: ovrVector2f,
        orthoDistance: f32,
        HmdToEyeOffsetX: f32,
    ) -> ovrMatrix4f;
}
extern "C" {
    pub fn ovr_CalcEyePoses(
        headPose: ovrPosef,
        hmdToEyeOffset: *const ovrVector3f,
        outEyePoses: *mut ovrPosef,
    );
}
extern "C" {
    pub fn ovr_CalcEyePoses2(
        headPose: ovrPosef,
        HmdToEyePose: *const ovrPosef,
        outEyePoses: *mut ovrPosef,
    );
}
extern "C" {
    pub fn ovr_GetEyePoses(
        session: ovrSession,
        frameIndex: ::std::os::raw::c_longlong,
        latencyMarker: ovrBool,
        hmdToEyeOffset: *const ovrVector3f,
        outEyePoses: *mut ovrPosef,
        outSensorSampleTime: *mut f64,
    );
}
extern "C" {
    pub fn ovr_GetEyePoses2(
        session: ovrSession,
        frameIndex: ::std::os::raw::c_longlong,
        latencyMarker: ovrBool,
        HmdToEyePose: *const ovrPosef,
        outEyePoses: *mut ovrPosef,
        outSensorSampleTime: *mut f64,
    );
}
extern "C" {
    #[doc = " Tracking poses provided by the SDK come in a right-handed coordinate system. If an application"]
    #[doc = " is passing in ovrProjection_LeftHanded into ovrMatrix4f_Projection, then it should also use"]
    #[doc = " this function to flip the HMD tracking poses to be left-handed."]
    #[doc = ""]
    #[doc = " While this utility function is intended to convert a left-handed ovrPosef into a right-handed"]
    #[doc = " coordinate system, it will also work for converting right-handed to left-handed since the"]
    #[doc = " flip operation is the same for both cases."]
    #[doc = ""]
    #[doc = " \\param[in]  inPose that is right-handed"]
    #[doc = " \\param[out] outPose that is requested to be left-handed (can be the same pointer to inPose)"]
    #[doc = ""]
    pub fn ovrPosef_FlipHandedness(inPose: *const ovrPosef, outPose: *mut ovrPosef);
}
extern "C" {
    #[doc = " Reads an audio channel from Wav (Waveform Audio File) data."]
    #[doc = " Input must be a byte buffer representing a valid Wav file. Audio samples from the specified"]
    #[doc = " channel are read,"]
    #[doc = " converted to float [-1.0f, 1.0f] and returned through ovrAudioChannelData."]
    #[doc = ""]
    #[doc = " Supported formats: PCM 8b, 16b, 32b and IEEE float (little-endian only)."]
    #[doc = ""]
    #[doc = " \\param[out] outAudioChannel output audio channel data."]
    #[doc = " \\param[in] inputData a binary buffer representing a valid Wav file data."]
    #[doc = " \\param[in] dataSizeInBytes size of the buffer in bytes."]
    #[doc = " \\param[in] stereoChannelToUse audio channel index to extract (0 for mono)."]
    #[doc = ""]
    pub fn ovr_ReadWavFromBuffer(
        outAudioChannel: *mut ovrAudioChannelData,
        inputData: *const ::std::os::raw::c_void,
        dataSizeInBytes: ::std::os::raw::c_int,
        stereoChannelToUse: ::std::os::raw::c_int,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Generates playable Touch Haptics data from an audio channel."]
    #[doc = ""]
    #[doc = " \\param[out] outHapticsClip generated Haptics clip."]
    #[doc = " \\param[in] audioChannel input audio channel data."]
    #[doc = " \\param[in] genMode mode used to convert and audio channel data to Haptics data."]
    #[doc = ""]
    pub fn ovr_GenHapticsFromAudioData(
        outHapticsClip: *mut ovrHapticsClip,
        audioChannel: *const ovrAudioChannelData,
        genMode: ovrHapticsGenMode,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Releases memory allocated for ovrAudioChannelData. Must be called to avoid memory leak."]
    #[doc = " \\param[in] audioChannel pointer to an audio channel"]
    #[doc = ""]
    pub fn ovr_ReleaseAudioChannelData(audioChannel: *mut ovrAudioChannelData);
}
extern "C" {
    #[doc = " Releases memory allocated for ovrHapticsClip. Must be called to avoid memory leak."]
    #[doc = " \\param[in] hapticsClip pointer to a haptics clip"]
    #[doc = ""]
    pub fn ovr_ReleaseHapticsClip(hapticsClip: *mut ovrHapticsClip);
}
extern "C" {
    #[doc = " Get a list of Vulkan vkInstance extensions required for VR."]
    #[doc = ""]
    #[doc = " Returns a list of strings delimited by a single space identifying Vulkan extensions that must"]
    #[doc = " be enabled in order for the VR runtime to support Vulkan-based applications. The returned"]
    #[doc = " list reflects the current runtime version and the GPU the VR system is currently connected to."]
    #[doc = ""]
    #[doc = " \\param[in]  luid Specifies the luid for the relevant GPU, which is returned from ovr_Create."]
    #[doc = " \\param[in]  extensionNames is a character buffer which will receive a list of extension name"]
    #[doc = "               strings, separated by a single space char between each extension."]
    #[doc = " \\param[in]  inoutExtensionNamesSize indicates on input the capacity of extensionNames in chars."]
    #[doc = "               On output it returns the number of characters written to extensionNames,"]
    #[doc = "               including the terminating 0 char. In the case of this function returning"]
    #[doc = "               ovrError_InsufficientArraySize, the required inoutExtensionNamesSize is returned."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of failure, use"]
    #[doc = "         ovr_GetLastErrorInfo to get more information. Returns ovrError_InsufficientArraySize in"]
    #[doc = "         the case that inoutExtensionNameSize didn't have enough space, in which case"]
    #[doc = "         inoutExtensionNameSize will return the required inoutExtensionNamesSize."]
    #[doc = ""]
    #[doc = " <b>Example code</b>"]
    #[doc = "     \\code{.cpp}"]
    #[doc = "         char extensionNames[4096];"]
    #[doc = "         uint32_t extensionNamesSize = sizeof(extensionNames);"]
    #[doc = "         ovr_GetInstanceExtensionsVk(luid, extensionsnames, &extensionNamesSize);"]
    #[doc = ""]
    #[doc = "         uint32_t extensionCount = 0;"]
    #[doc = "         const char* extensionNamePtrs[256];"]
    #[doc = "         for(const char* p = extensionNames; *p; ++p) {"]
    #[doc = "             if((p == extensionNames) || (p[-1] == ' ')) {"]
    #[doc = "                 extensionNamePtrs[extensionCount++] = p;"]
    #[doc = "                 if (p[-1] == ' ')"]
    #[doc = "                     p[-1] = '\\0';"]
    #[doc = "             }"]
    #[doc = "         }"]
    #[doc = ""]
    #[doc = "         VkInstanceCreateInfo info = { ... };"]
    #[doc = "         info.enabledExtensionCount = extensionCount;"]
    #[doc = "         info.ppEnabledExtensionNames = extensionNamePtrs;"]
    #[doc = "         [...]"]
    #[doc = "     \\endcode"]
    #[doc = ""]
    pub fn ovr_GetInstanceExtensionsVk(
        luid: ovrGraphicsLuid,
        extensionNames: *mut ::std::os::raw::c_char,
        inoutExtensionNamesSize: *mut u32,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Get a list of Vulkan vkDevice extensions required for VR."]
    #[doc = ""]
    #[doc = " Returns a list of strings delimited by a single space identifying Vulkan extensions that must"]
    #[doc = " be enabled in order for the VR runtime to support Vulkan-based applications. The returned"]
    #[doc = " list reflects the current runtime version and the GPU the VR system is currently connected to."]
    #[doc = ""]
    #[doc = " \\param[in]  luid Specifies the luid for the relevant GPU, which is returned from ovr_Create."]
    #[doc = " \\param[in]  extensionNames is a character buffer which will receive a list of extension name"]
    #[doc = "               strings, separated by a single space char between each extension."]
    #[doc = " \\param[in]  inoutExtensionNamesSize indicates on input the capacity of extensionNames in chars."]
    #[doc = "               On output it returns the number of characters written to extensionNames,"]
    #[doc = "               including the terminating 0 char. In the case of this function returning"]
    #[doc = "               ovrError_InsufficientArraySize, the required inoutExtensionNamesSize is returned."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of failure, use"]
    #[doc = "         ovr_GetLastErrorInfo to get more information. Returns ovrError_InsufficientArraySize in"]
    #[doc = "         the case that inoutExtensionNameSize didn't have enough space, in which case"]
    #[doc = "         inoutExtensionNameSize will return the required inoutExtensionNamesSize."]
    #[doc = ""]
    pub fn ovr_GetDeviceExtensionsVk(
        luid: ovrGraphicsLuid,
        extensionNames: *mut ::std::os::raw::c_char,
        inoutExtensionNamesSize: *mut u32,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Find VkPhysicalDevice matching ovrGraphicsLuid"]
    #[doc = ""]
    #[doc = " \\param[in]  session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in]  luid Specifies the luid returned from ovr_Create."]
    #[doc = " \\param[in]  instance Specifies a VkInstance to search for matching luids in."]
    #[doc = " \\param[out] out_physicalDevice Returns the VkPhysicalDevice matching the instance and luid."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of failure, use"]
    #[doc = "         ovr_GetLastErrorInfo to get more information."]
    #[doc = ""]
    #[doc = " \\note This function enumerates the current physical devices and returns the one matching the"]
    #[doc = " luid. It must be called at least once prior to any ovr_CreateTextureSwapChainVk or"]
    #[doc = " ovr_CreateMirrorTextureWithOptionsVk calls, and the instance must remain valid for the lifetime"]
    #[doc = " of the returned objects. It is assumed the VkDevice created by the application will be for the"]
    #[doc = " returned physical device."]
    #[doc = ""]
    pub fn ovr_GetSessionPhysicalDeviceVk(
        session: ovrSession,
        luid: ovrGraphicsLuid,
        instance: VkInstance,
        out_physicalDevice: *mut VkPhysicalDevice,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Select VkQueue to block on till rendering is complete"]
    #[doc = ""]
    #[doc = " \\param[in]  session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in]  queue Specifies a VkQueue to add a VkFence operation to and wait on."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of failure, use"]
    #[doc = "         ovr_GetLastErrorInfo to get more information."]
    #[doc = ""]
    #[doc = " \\note The queue may be changed at any time but only the value at the time ovr_SubmitFrame"]
    #[doc = " is called will be used. ovr_SetSynchronizationQueueVk must be called with a valid VkQueue"]
    #[doc = " created on the same VkDevice the texture sets were created on prior to the first call to"]
    #[doc = " ovr_SubmitFrame. An internally created VkFence object will be signalled by the completion"]
    #[doc = " of operations on queue and waited on to synchronize the VR compositor."]
    #[doc = ""]
    pub fn ovr_SetSynchronizationQueueVk(session: ovrSession, queue: VkQueue) -> ovrResult;
}
extern "C" {
    #[doc = " Create Texture Swap Chain suitable for use with Vulkan"]
    #[doc = ""]
    #[doc = " \\param[in]  session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in]  device Specifies the application's VkDevice to create resources with."]
    #[doc = " \\param[in]  desc Specifies requested texture properties. See notes for more info"]
    #[doc = "             about texture format."]
    #[doc = " \\param[out] out_TextureSwapChain Returns the created ovrTextureSwapChain, which will be valid"]
    #[doc = "             upon a successful return value, else it will be NULL."]
    #[doc = "             This texture chain must be eventually destroyed via ovr_DestroyTextureSwapChain"]
    #[doc = "             before destroying the session with ovr_Destroy."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of failure, use"]
    #[doc = "         ovr_GetLastErrorInfo to get more information."]
    #[doc = ""]
    #[doc = " \\note The texture format provided in \\a desc should be thought of as the format the"]
    #[doc = "       distortion-compositor will use for the ShaderResourceView when reading the contents"]
    #[doc = "       of the texture. To that end, it is highly recommended that the application"]
    #[doc = "       requests texture swapchain formats that are in sRGB-space"]
    #[doc = "       (e.g. OVR_FORMAT_R8G8B8A8_UNORM_SRGB) as the compositor does sRGB-correct rendering."]
    #[doc = "       As such, the compositor relies on the GPU's hardware sampler to do the sRGB-to-linear"]
    #[doc = "       conversion. If the application still prefers to render to a linear format (e.g."]
    #[doc = "       OVR_FORMAT_R8G8B8A8_UNORM) while handling the linear-to-gamma conversion via"]
    #[doc = "       SPIRV code, then the application must still request the corresponding sRGB format and"]
    #[doc = "       also use the \\a ovrTextureMisc_DX_Typeless flag in the ovrTextureSwapChainDesc's"]
    #[doc = "       Flag field. This will allow the application to create a RenderTargetView that is the"]
    #[doc = "       desired linear format while the compositor continues to treat it as sRGB. Failure to"]
    #[doc = "       do so will cause the compositor to apply unexpected gamma conversions leading to"]
    #[doc = "       gamma-curve artifacts. The \\a ovrTextureMisc_DX_Typeless flag for depth buffer formats"]
    #[doc = "       (e.g. OVR_FORMAT_D32_FLOAT) is ignored as they are always"]
    #[doc = "       converted to be typeless."]
    #[doc = ""]
    #[doc = " \\see ovr_GetTextureSwapChainLength"]
    #[doc = " \\see ovr_GetTextureSwapChainCurrentIndex"]
    #[doc = " \\see ovr_GetTextureSwapChainDesc"]
    #[doc = " \\see ovr_GetTextureSwapChainBufferVk"]
    #[doc = " \\see ovr_DestroyTextureSwapChain"]
    #[doc = ""]
    pub fn ovr_CreateTextureSwapChainVk(
        session: ovrSession,
        device: VkDevice,
        desc: *const ovrTextureSwapChainDesc,
        out_TextureSwapChain: *mut ovrTextureSwapChain,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Get a specific VkImage within the chain"]
    #[doc = ""]
    #[doc = " \\param[in]  session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in]  chain Specifies an ovrTextureSwapChain previously returned by"]
    #[doc = "             ovr_CreateTextureSwapChainVk"]
    #[doc = " \\param[in]  index Specifies the index within the chain to retrieve."]
    #[doc = "             Must be between 0 and length (see ovr_GetTextureSwapChainLength),"]
    #[doc = "             or may pass -1 to get the buffer at the CurrentIndex location (saving a"]
    #[doc = "             call to GetTextureSwapChainCurrentIndex)."]
    #[doc = " \\param[out] out_Image Returns the VkImage retrieved."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of failure, use"]
    #[doc = "         ovr_GetLastErrorInfo to get more information."]
    #[doc = ""]
    pub fn ovr_GetTextureSwapChainBufferVk(
        session: ovrSession,
        chain: ovrTextureSwapChain,
        index: ::std::os::raw::c_int,
        out_Image: *mut VkImage,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Create Mirror Texture which is auto-refreshed to mirror Rift contents produced by this"]
    #[doc = " application."]
    #[doc = ""]
    #[doc = " A second call to ovr_CreateMirrorTextureWithOptionsVk for a given ovrSession before destroying"]
    #[doc = " the first one is not supported and will result in an error return."]
    #[doc = ""]
    #[doc = " \\param[in]  session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in]  device Specifies the VkDevice to create resources with."]
    #[doc = " \\param[in]  desc Specifies requested texture properties. See notes for more info"]
    #[doc = "             about texture format."]
    #[doc = " \\param[out] out_MirrorTexture Returns the created ovrMirrorTexture, which will be"]
    #[doc = "             valid upon a successful return value, else it will be NULL."]
    #[doc = "             This texture must be eventually destroyed via ovr_DestroyMirrorTexture before"]
    #[doc = "             destroying the session with ovr_Destroy."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of failure, use"]
    #[doc = "         ovr_GetLastErrorInfo to get more information."]
    #[doc = ""]
    #[doc = " \\note The texture format provided in \\a desc should be thought of as the format the"]
    #[doc = "       compositor will use for the VkImageView when writing into mirror texture. To that end,"]
    #[doc = "       it is highly recommended that the application requests a mirror texture format that is"]
    #[doc = "       in sRGB-space (e.g. OVR_FORMAT_R8G8B8A8_UNORM_SRGB) as the compositor does sRGB-correct"]
    #[doc = "       rendering. If however the application wants to still read the mirror texture as a"]
    #[doc = "       linear format (e.g. OVR_FORMAT_R8G8B8A8_UNORM) and handle the sRGB-to-linear conversion"]
    #[doc = "       in SPIRV code, then it is recommended the application still requests an sRGB format and"]
    #[doc = "       also use the \\a ovrTextureMisc_DX_Typeless flag in the ovrMirrorTextureDesc's"]
    #[doc = "       Flags field. This will allow the application to bind a ShaderResourceView that is a"]
    #[doc = "       linear format while the compositor continues to treat is as sRGB. Failure to do so will"]
    #[doc = "       cause the compositor to apply unexpected gamma conversions leading to"]
    #[doc = "       gamma-curve artifacts."]
    #[doc = ""]
    #[doc = " <b>Example code</b>"]
    #[doc = "     \\code{.cpp}"]
    #[doc = "         ovrMirrorTexture     mirrorTexture = nullptr;"]
    #[doc = "         ovrMirrorTextureDesc mirrorDesc = {};"]
    #[doc = "         mirrorDesc.Format = OVR_FORMAT_R8G8B8A8_UNORM_SRGB;"]
    #[doc = "         mirrorDesc.Width  = mirrorWindowWidth;"]
    #[doc = "         mirrorDesc.Height = mirrorWindowHeight;"]
    #[doc = "         ovrResult result = ovr_CreateMirrorTextureWithOptionsVk(session, vkDevice, &mirrorDesc,"]
    #[doc = "         &mirrorTexture);"]
    #[doc = "         [...]"]
    #[doc = "         // Destroy the texture when done with it."]
    #[doc = "         ovr_DestroyMirrorTexture(session, mirrorTexture);"]
    #[doc = "         mirrorTexture = nullptr;"]
    #[doc = "     \\endcode"]
    #[doc = ""]
    #[doc = " \\see ovr_GetMirrorTextureBufferVk"]
    #[doc = " \\see ovr_DestroyMirrorTexture"]
    #[doc = ""]
    pub fn ovr_CreateMirrorTextureWithOptionsVk(
        session: ovrSession,
        device: VkDevice,
        desc: *const ovrMirrorTextureDesc,
        out_MirrorTexture: *mut ovrMirrorTexture,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Get a the underlying mirror VkImage"]
    #[doc = ""]
    #[doc = " \\param[in]  session Specifies an ovrSession previously returned by ovr_Create."]
    #[doc = " \\param[in]  mirrorTexture Specifies an ovrMirrorTexture previously returned by"]
    #[doc = " ovr_CreateMirrorTextureWithOptionsVk"]
    #[doc = " \\param[out] out_Image Returns the VkImage pointer retrieved."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure. In the case of failure, use"]
    #[doc = "         ovr_GetLastErrorInfo to get more information."]
    #[doc = ""]
    #[doc = " <b>Example code</b>"]
    #[doc = "     \\code{.cpp}"]
    #[doc = "         VkImage mirrorImage = VK_NULL_HANDLE;"]
    #[doc = "         ovr_GetMirrorTextureBufferVk(session, mirrorTexture, &mirrorImage);"]
    #[doc = "         ..."]
    #[doc = "         vkCmdBlitImage(commandBuffer, mirrorImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,"]
    #[doc = "         presentImage, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region, VK_FILTER_LINEAR);"]
    #[doc = "         ..."]
    #[doc = "         vkQueuePresentKHR(queue, &presentInfo);"]
    #[doc = "     \\endcode"]
    #[doc = ""]
    pub fn ovr_GetMirrorTextureBufferVk(
        session: ovrSession,
        mirrorTexture: ovrMirrorTexture,
        out_Image: *mut VkImage,
    ) -> ovrResult;
}
